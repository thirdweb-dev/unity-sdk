<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NBitcoin</name>
    </assembly>
    <members>
        <member name="T:NBitcoin.Base58Data">
            <summary>
            Base class for all Base58 check representation of data
            </summary>
        </member>
        <member name="T:NBitcoin.BitStream">
            <summary> Provides a view of an array of bits as a stream of bits. </summary>
        </member>
        <member name="T:NBitcoin.GolombRiceFilter">
            <summary>
            Implements a Golomb-coded set to be use in the creation of client-side filter
            for a new kind Bitcoin light clients. This code is based on the BIP:
            https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki
            </summary>
        </member>
        <member name="P:NBitcoin.GolombRiceFilter.P">
            <summary>
            a value which is computed as 1/fp where fp is the desired false positive rate.
            </summary>
        </member>
        <member name="P:NBitcoin.GolombRiceFilter.M">
            <summary>
            a value which is computed as N * fp (or false positive rate = 1/M).
            this value allows filter to uniquely tune the range that items are hashed onto
            before compressing
            </summary>
        </member>
        <member name="P:NBitcoin.GolombRiceFilter.N">
            <summary>
            Number of elements in the filter
            </summary>
        </member>
        <member name="P:NBitcoin.GolombRiceFilter.Data">
            <summary>
            Raw filter data
            </summary>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.Parse(System.String)">
            <summary>
            Creates a new Golomb-Rice filter from the data byte array which
            contains a serialized filter. Uses the DefaultP value (20).
            </summary>
            <param name="data">A serialized Golomb-Rice filter.</param>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.#ctor(System.Byte[])">
            <summary>
            Creates a new Golomb-Rice filter from the data byte array which
            contains a serialized filter. Uses the DefaultP value (20).
            </summary>
            <param name="data">A serialized Golomb-Rice filter.</param>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.#ctor(System.Byte[],System.Byte,System.UInt32)">
            <summary>
            Creates a new Golomb-Rice filter from the data byte array which
            contains a serialized filter.
            </summary>
            <param name="data">A serialized Golomb-Rice filter.</param>
            <param name="p">The P value to use.</param>
            <param name="m">The M value to use.</param>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.#ctor(System.Byte[],System.Int32,System.Byte,System.UInt32)">
            <summary>
            Creates a new Golomb-Rice filter from the data byte array.
            </summary>
            <param name="data">A serialized Golomb-Rice filter.</param>
            <param name="n">The number of elements in the filter.</param>
            <param name="p">The P value to use.</param>
            <param name="m">The M value to use.</param>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.ConstructHashedSet(System.Byte,System.Int32,System.UInt32,System.Byte[],System.Collections.Generic.IEnumerable{System.Byte[]},System.Int32)">
            <summary>
            Computes the sorted-and-uncompressed list of values to be included in the filter.
            /// </summary>
            <param name="P">P value used.</param>
            <param name="key">Key used for hashing the datalements.</param>
            <param name="data">Data elements to be computed in the list.</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.GetHeader(NBitcoin.uint256)">
            <summary>
            Calculates the filter's header.
            </summary>
            <param name="previousHeader">Previous filter header.</param>
            <returns>The filter header.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.Match(System.Byte[],System.Byte[])">
            <summary>
            Checks if the value passed is in the filter.
            </summary>
            <param name="data">Data element to check in the filter.</param>
            <param name="key">Key used for hashing the data elements.</param>
            <returns>true if the element is in the filter, otherwise false.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.MatchAny(System.Byte[][],System.Byte[])">
            <summary>
            Checks if any of the provided elements is in the filter.
            </summary>
            <param name="data">Data elements to check in the filter.</param>
            <param name="key">Key used for hashing the data elements.</param>
            <returns>true if at least one of the elements is in the filter, otherwise false.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.MatchAny(System.Collections.Generic.IEnumerable{System.Byte[]},System.Byte[])">
            <summary>
            Checks if any of the provided elements is in the filter.
            </summary>
            <param name="data">Data elements to check in the filter.</param>
            <param name="key">Key used for hashing the data elements.</param>
            <returns>true if at least one of the elements is in the filter, otherwise false.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.MatchAny(System.Collections.Generic.IEnumerable{System.Byte[]},System.Int32,System.Byte[])">
            <summary>
            Checks if any of the provided elements is in the filter.
            </summary>
            <param name="data">Data elements to check in the filter.</param>
            <param name="key">Key used for hashing the data elements.</param>
            <returns>true if at least one of the elements is in the filter, otherwise false.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.ToBytes">
            <summary>
            Serialize the filter as a array of bytes using [varint(N) | data].
            </summary>
            <returns>A array of bytes with the serialized filter data.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.ToString">
            <summary>
            Serialize the filter as hexadecimal string.
            </summary>
            <returns>A string with the serialized filter data</returns>
        </member>
        <member name="T:NBitcoin.GolombRiceFilterBuilder">
            <summary>
            Class for creating Golomb-Rice filters for a given block.
            It provides methods for building two kind of filters out-of-the-box:
            Basic Filters and Extenden Filters.
            </summary>
        </member>
        <member name="T:NBitcoin.GolombRiceFilterBuilder.ByteArrayComparer">
            <summary>
            Helper class for making sure not two identical data elements are
            included in a filter.
            </summary>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.BuildBasicFilter(NBitcoin.Block)">
             <summary>
             Builds the basic filter for a given block.
            
             The basic filter is designed to contain everything that a light client needs to sync a regular Bitcoin wallet.
             A basic filter MUST contain exactly the following items for each transaction in a block:
              * The outpoint of each input, except for the coinbase transaction
              * The scriptPubKey of each output
              * The txid of the transaction itself
             </summary>
             <param name="block">The block used for building the filter.</param>
             <returns>The basic filter for the block.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.#ctor">
            <summary>
            Creates a new Golob-Rice filter builder.
            </summary>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.SetKey(NBitcoin.uint256)">
            <summary>
            Sets the key used for hashing the filter data elements.
            The first half of the block hash is used as described in the BIP.
            </summary>
            <param name="blockHash">The block hash which the hashing key is derived from.</param>
            <returns>The updated filter builder instance</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.SetP(System.Int32)">
            <summary>
            Sets the P value to use.
            </summary>
            <param name="p">P value</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.SetM(System.UInt32)">
            <summary>
            Sets the M value to use.
            </summary>
            <param name="m">M value</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddTxId(NBitcoin.uint256)">
            <summary>
            Adds a transacion id to the list of elements that will be used for building the filter.
            </summary>
            <param name="id">The transaction id.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddScriptPubkey(NBitcoin.Script)">
            <summary>
            Adds a scriptPubKey to the list of elements that will be used for building the filter.
            </summary>
            <param name="scriptPubkey">The scriptPubkey.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddScriptSig(NBitcoin.Script)">
            <summary>
            Adds a scriptSig to the list of elements that will be used for building the filter.
            </summary>
            <param name="scriptSig">The scriptSig.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddWitness(NBitcoin.WitScript)">
            <summary>
            Adds a witness stack to the list of elements that will be used for building the filter.
            </summary>
            <param name="witScript">The witScript.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddOutPoint(NBitcoin.OutPoint)">
            <summary>
            Adds an outpoint to the list of elements that will be used for building the filter.
            </summary>
            <param name="outpoint">The outpoint.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddEntries(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            Adds a list of elements to the list of elements that will be used for building the filter.
            </summary>
            <param name="entries">The entries.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.Build">
            <summary>
            Builds the Golomb-Rice filters from the parameters and data elements included.
            </summary>
            <returns>The built filter.</returns>
        </member>
        <member name="P:NBitcoin.PSBTSettings.CustomBuilderExtensions">
            <summary>
            Use custom builder extensions to customize finalization
            </summary>
        </member>
        <member name="P:NBitcoin.PSBTSettings.IsSmart">
            <summary>
            Try to do anything that is possible to deduce PSBT information from input information
            </summary>
        </member>
        <member name="M:NBitcoin.PSBT.AddTransactions(NBitcoin.Transaction[])">
            <summary>
            Add transactions to non segwit outputs
            </summary>
            <param name="parentTransactions">Parent transactions</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.Combine(NBitcoin.PSBT)">
             <summary>
             If an other PSBT has a specific field and this does not have it, then inject that field to this.
             otherwise leave it as it is.
            
             If you need to call this on transactions with different global transaction, use <see cref="M:NBitcoin.PSBT.UpdateFrom(NBitcoin.PSBT)"/> instead.
             </summary>
             <param name="other">Another PSBT to takes information from</param>
             <exception cref="T:System.ArgumentException">Can not Combine PSBT with different global tx.</exception>
             <returns>This instance</returns>
        </member>
        <member name="M:NBitcoin.PSBT.UpdateFrom(NBitcoin.PSBT)">
             <summary>
             If an other PSBT has a specific field and this does not have it, then inject that field to this.
             otherwise leave it as it is.
            
             Contrary to <see cref="M:NBitcoin.PSBT.Combine(NBitcoin.PSBT)"/>, it can be called on PSBT with a different global transaction.
             </summary>
             <param name="other">Another PSBT to takes information from</param>
             <returns>This instance</returns>
        </member>
        <member name="M:NBitcoin.PSBT.CoinJoin(NBitcoin.PSBT)">
            <summary>
            Join two PSBT into one CoinJoin PSBT.
            This is an immutable method.
            TODO: May need assertion for sighash type?
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.PSBT.SignAll(NBitcoin.ScriptPubKeyType,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Sign all inputs which derive <paramref name="accountKey"/> of type <paramref name="scriptPubKeyType"/>.
            </summary>
            <param name="scriptPubKeyType">The way to derive addresses from the accountKey</param>
            <param name="accountKey">The account key with which to sign</param>
            <param name="accountKeyPath">The account key path (eg. [masterFP]/49'/0'/0')</param>
            <param name="sigHash">The SigHash</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.SignAll(NBitcoin.ScriptPubKeyType,NBitcoin.IHDKey)">
            <summary>
            Sign all inputs which derive <paramref name="accountKey"/> of type <paramref name="scriptPubKeyType"/>.
            </summary>
            <param name="scriptPubKeyType">The way to derive addresses from the accountKey</param>
            <param name="accountKey">The account key with which to sign</param>
            <param name="sigHash">The SigHash</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.SignAll(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey)">
            <summary>
            Sign all inputs which derive addresses from <paramref name="accountHDScriptPubKey"/> and that need to be signed by <paramref name="accountKey"/>.
            </summary>
            <param name="accountHDScriptPubKey">The address generator</param>
            <param name="accountKey">The account key with which to sign</param>
            <param name="sigHash">The SigHash</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.SignAll(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Sign all inputs which derive addresses from <paramref name="accountHDScriptPubKey"/> and that need to be signed by <paramref name="accountKey"/>.
            </summary>
            <param name="accountHDScriptPubKey">The address generator</param>
            <param name="accountKey">The account key with which to sign</param>
            <param name="accountKeyPath">The account key path (eg. [masterFP]/49'/0'/0')</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.TryGetFee(NBitcoin.Money@)">
            <summary>
            Returns the fee of the transaction being signed
            </summary>
            <param name="fee"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.PSBT.GetFee">
            <summary>
            Returns the fee of the transaction being signed
            </summary>
            <returns>The fees</returns>
            <exception cref="T:System.InvalidOperationException">Not enough information to know about the fee</exception>
        </member>
        <member name="M:NBitcoin.PSBT.TryGetEstimatedFeeRate(NBitcoin.FeeRate@)">
            <summary>
            Returns the fee rate of the transaction. If the PSBT is finalized, then the exact rate is returned, else an estimation is made.
            </summary>
            <param name="estimatedFeeRate"></param>
            <returns>True if could get the estimated fee rate</returns>
        </member>
        <member name="M:NBitcoin.PSBT.TryGetVirtualSize(System.Int32@)">
            <summary>
            Returns the virtual transaction size of the transaction. If the PSBT is finalized, then the exact virtual size.
            </summary>
            <param name="vsize">The calculated virtual size</param>
            <returns>True if could get the virtual size could get estimated</returns>
        </member>
        <member name="M:NBitcoin.PSBT.GetEstimatedFeeRate">
            <summary>
            Returns the fee rate of the transaction. If the PSBT is finalized, then the exact rate is returned, else an estimation is made.
            </summary>
            <returns>The estimated fee</returns>
            <exception cref="T:System.InvalidOperationException">Not enough information to know about the fee rate</exception>
        </member>
        <member name="M:NBitcoin.PSBT.PrecomputeTransactionData">
            <summary>
            Returns a data structure precomputing some hash values that are needed for all inputs to be signed in the transaction.
            </summary>
            <returns>The PrecomputedTransactionData</returns>
            <exception cref="T:NBitcoin.PSBTException">Throw if the PSBT is missing some previous outputs.</exception>
        </member>
        <member name="M:NBitcoin.PSBT.ExtractTransaction">
            <summary>
            Extract the fully signed transaction from the PSBT
            </summary>
            <returns>The fully signed transaction</returns>
            <exception cref="T:System.InvalidOperationException">PSBTInputs are not all finalized</exception>
        </member>
        <member name="M:NBitcoin.PSBT.TryGetFinalizedHash(NBitcoin.uint256@)">
            <summary>
            Get the expected hash once the transaction is fully signed
            </summary>
            <param name="hash">The hash once fully signed</param>
            <returns>True if we can know the expected hash. False if we can't (unsigned non-segwit).</returns>
        </member>
        <member name="M:NBitcoin.PSBT.Clone">
            <summary>
            Clone this PSBT
            </summary>
            <returns>A cloned PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.Clone(System.Boolean)">
            <summary>
            Clone this PSBT
            </summary>
            <param name="keepOriginalTransactionInformation">Whether the original scriptSig and witScript or inputs is saved</param>
            <returns>A cloned PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.GetBalance(NBitcoin.ScriptPubKeyType,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Get the balance change if you were signing this transaction.
            </summary>
            <param name="accountHDScriptPubKey">The hdScriptPubKey used to generate addresses</param>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>The balance change</returns>
        </member>
        <member name="M:NBitcoin.PSBT.GetBalance(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Get the balance change if you were signing this transaction.
            </summary>
            <param name="accountHDScriptPubKey">The hdScriptPubKey used to generate addresses</param>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>The balance change</returns>
        </member>
        <member name="M:NBitcoin.PSBT.CoinsFor(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Filter the coins which contains the <paramref name="accountKey"/> and <paramref name="accountKeyPath"/> in the HDKeys and derive
            the same scriptPubKeys as <paramref name="accountHDScriptPubKey"/>.
            </summary>
            <param name="accountHDScriptPubKey">The hdScriptPubKey used to generate addresses</param>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>Inputs with HD keys matching masterFingerprint and account key</returns>
        </member>
        <member name="M:NBitcoin.PSBT.HDKeysFor(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Filter the keys which contains the <paramref name="accountKey"/> and <paramref name="accountKeyPath"/> in the HDKeys and whose input/output
            the same scriptPubKeys as <paramref name="accountHDScriptPubKey"/>.
            </summary>
            <param name="accountHDScriptPubKey">The hdScriptPubKey used to generate addresses</param>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>HD Keys matching master root key</returns>
        </member>
        <member name="M:NBitcoin.PSBT.HDKeysFor(NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Filter the keys which contains the <paramref name="accountKey"/> and <paramref name="accountKeyPath"/>.
            </summary>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>HD Keys matching master root key</returns>
        </member>
        <member name="M:NBitcoin.PSBT.AddKeyPath(NBitcoin.IHDKey,NBitcoin.KeyPath[])">
            <summary>
            Add keypath information to this PSBT for each input or output involving it
            </summary>
            <param name="masterKey">The master key of the keypaths</param>
            <param name="paths">The path of the public keys</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.AddKeyPath(NBitcoin.IHDKey,System.Tuple{NBitcoin.KeyPath,NBitcoin.Script}[])">
            <summary>
            Add keypath information to this PSBT for each input or output involving it
            </summary>
            <param name="masterKey">The master key of the keypaths</param>
            <param name="paths">The path of the public keys with their expected scriptPubKey</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.AddKeyPath(NBitcoin.PubKey,NBitcoin.RootedKeyPath)">
            <summary>
            Add keypath information to this PSBT for each input or output involving it
            </summary>
            <param name="pubkey">The public key which need to sign</param>
            <param name="rootedKeyPath">The keypath to this public key</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.AddKeyPath(NBitcoin.PubKey,NBitcoin.RootedKeyPath,NBitcoin.Script)">
            <summary>
            Add keypath information to this PSBT, if the PSBT all finalized this operation is a no-op
            </summary>
            <param name="pubkey">The public key which need to sign</param>
            <param name="rootedKeyPath">The keypath to this public key</param>
            <param name="scriptPubKey">A specific scriptPubKey this pubkey is involved with</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBT.RebaseKeyPaths(NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Rebase the keypaths.
            If a PSBT updater only know the child HD public key but not the root one, another updater knowing the parent master key it is based on
            can rebase the paths. If the PSBT is all finalized this operation is a no-op
            </summary>
            <param name="accountKey">The current account key</param>
            <param name="newRoot">The KeyPath with the fingerprint of the new root key</param>
            <returns>This PSBT</returns>
        </member>
        <member name="M:NBitcoin.PSBTCoin.HDKeysFor(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Filter the keys which contains the <paramref name="accountKey"/> and <paramref name="accountKeyPath"/> in the HDKeys and whose input/output
            the same scriptPubKeys as <paramref name="accountHDScriptPubKey"/>.
            </summary>
            <param name="accountHDScriptPubKey">The accountHDScriptPubKey used to generate addresses</param>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>HD Keys matching master root key</returns>
        </member>
        <member name="P:NBitcoin.PSBTHDKeyMatch.AddressKeyPath">
            <summary>
            KeyPath relative to the accountKey to PubKey
            </summary>
        </member>
        <member name="M:NBitcoin.PSBTCoinList`1.CoinsFor(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Filter the coins which contains the <paramref name="accountKey"/> and <paramref name="accountKeyPath"/> in the HDKeys and derive
            the same scriptPubKeys as <paramref name="accountHDScriptPubKey"/>.
            </summary>
            <param name="accountHDScriptPubKey">The hdScriptPubKey used to generate addresses</param>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>Inputs with HD keys matching masterFingerprint and account key</returns>
        </member>
        <member name="M:NBitcoin.PSBTCoinList`1.HDKeysFor(NBitcoin.IHDScriptPubKey,NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Filter the keys which contains the <paramref name="accountKey"/> and <paramref name="accountKeyPath"/> in the HDKeys and whose input/output 
            the same scriptPubKeys as <paramref name="accountHDScriptPubKey"/>.
            </summary>
            <param name="accountHDScriptPubKey">The hdScriptPubKey used to generate addresses</param>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>HD Keys matching master root key</returns>
        </member>
        <member name="M:NBitcoin.PSBTCoinList`1.HDKeysFor(NBitcoin.IHDKey,NBitcoin.RootedKeyPath)">
            <summary>
            Filter the keys which contains the <paramref name="accountKey"/> and <paramref name="accountKeyPath"/>.
            </summary>
            <param name="accountKey">The account key that will be used to sign (ie. 49'/0'/0')</param>
            <param name="accountKeyPath">The account key path</param>
            <returns>HD Keys matching master root key</returns>
        </member>
        <member name="M:NBitcoin.PSBTInput.SetSequence(System.UInt16)">
            <summary>
            Changes the nSequence field of the corresponding TxIn.
            You should not call this method if any PSBTInput in the same PSBT has a signature.
            Because the siagnature usually commits to the old nSequence value.
            </summary>
            <exception cref="T:System.InvalidOperationException">When at least one signature exists in any other inputs in the PSBT</exception>
        </member>
        <member name="M:NBitcoin.PSBTInput.UpdateFrom(NBitcoin.PSBTInput)">
            <summary>
            Import informations contained by <paramref name="other"/> into this instance.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:NBitcoin.PSBTInput.GetPushItems(NBitcoin.Script)">
            <summary>
            conovert partial sigs to suitable form for ScriptSig (or Witness).
            This will preserve the ordering of redeem script even if it did not follow bip67.
            </summary>
            <param name="redeem"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.PSBTInput.ClearForFinalize">
            <summary>
            Delete superflous information from a finalized input.
            This will not clear utxos since tx extractor might want to check the validity
            </summary>
            <exception cref="T:System.InvalidOperationException">The input need to be finalized</exception>
        </member>
        <member name="M:NBitcoin.PSBTInput.GetSignableCoin">
            <summary>
            Represent this input as a coin that can be used for signing operations.
            Returns null if <see cref="P:NBitcoin.PSBTInput.WitnessUtxo"/>, <see cref="P:NBitcoin.PSBTInput.NonWitnessUtxo"/> are not set
            or if <see cref="P:NBitcoin.PSBTCoin.WitnessScript"/> or <see cref="P:NBitcoin.PSBTCoin.RedeemScript"/> are missing but needed.
            </summary>
            <returns>The input as a signable coin</returns>
        </member>
        <member name="M:NBitcoin.PSBTInput.GetSignableCoin(System.String@)">
            <summary>
            Represent this input as a coin that can be used for signing operations.
            Returns null if <see cref="P:NBitcoin.PSBTInput.WitnessUtxo"/>, <see cref="P:NBitcoin.PSBTInput.NonWitnessUtxo"/> are not set
            or if <see cref="P:NBitcoin.PSBTCoin.WitnessScript"/> or <see cref="P:NBitcoin.PSBTCoin.RedeemScript"/> are missing but needed.
            </summary>
            <param name="error">If it is not possible to retrieve the signable coin, a human readable reason.</param>
            <returns>The input as a signable coin</returns>
        </member>
        <member name="M:NBitcoin.PSBTInput.TrySlimUTXO">
            <summary>
            Check if this satisfies criteria for witness. if it does, delete non_witness_utxo
            This is useful for following reasons.
            1. It will make a data smaller which is an obviously good thing.
            2. Future HW Wallet may not support non segwit tx and thus won't recognize non_witness_utxo
            3. To pass test in BIP174
            </summary>
        </member>
        <member name="M:NBitcoin.PSBTInput.GetCoin">
            <summary>
            Represent this input as a coin.
            Returns null if <see cref="P:NBitcoin.PSBTInput.WitnessUtxo"/> or <see cref="P:NBitcoin.PSBTInput.NonWitnessUtxo"/> is not set.
            </summary>
            <returns>The input as a coin</returns>
        </member>
        <member name="M:NBitcoin.PSBTOutput.UpdateFrom(NBitcoin.PSBTOutput)">
            <summary>
            Import informations contained by <paramref name="other"/> into this instance.
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:NBitcoin.BitcoinExtKey">
            <summary>
            Base58 representation of an ExtKey, within a particular network.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtKey.#ctor(System.String,NBitcoin.Network)">
            <summary>
            Constructor. Creates an extended key from the Base58 representation, checking the expected network.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtKey.#ctor(NBitcoin.ExtKey,NBitcoin.Network)">
            <summary>
            Constructor. Creates a representation of an extended key, within the specified network.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.IsValid">
            <summary>
            Gets whether the data is the correct expected length.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.ExtKey">
            <summary>
            Gets the extended key, converting from the Base58 representation.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.Type">
            <summary>
            Gets the type of item represented by this Base58 data.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.ScriptPubKey">
            <summary>
            Gets the script of the hash of the public key corresponing to the private key 
            of the extended key of this Base58 item.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtKey.Neuter">
            <summary>
            Gets the Base58 representation, in the same network, of the neutered extended key.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.PrivateKey">
            <summary>
            Gets the private key of the extended key of this Base58 item.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtKey.op_Implicit(NBitcoin.BitcoinExtKey)~NBitcoin.ExtKey">
            <summary>
            Implicit cast from BitcoinExtKey to ExtKey.
            </summary>
        </member>
        <member name="T:NBitcoin.BitcoinExtPubKey">
            <summary>
            Base58 representation of an ExtPubKey, within a particular network.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtPubKey.#ctor(System.String,NBitcoin.Network)">
            <summary>
            Constructor. Creates an extended public key from the Base58 representation, checking the expected network.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtPubKey.#ctor(NBitcoin.ExtPubKey,NBitcoin.Network)">
            <summary>
            Constructor. Creates a representation of an extended public key, within the specified network.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtPubKey.ExtPubKey">
            <summary>
            Gets the extended public key, converting from the Base58 representation.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtPubKey.Type">
            <summary>
            Gets the type of item represented by this Base58 data.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtPubKey.ScriptPubKey">
            <summary>
            Gets the script of the hash of the public key of the extended key of this Base58 item.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtPubKey.op_Implicit(NBitcoin.BitcoinExtPubKey)~NBitcoin.ExtPubKey">
            <summary>
            Implicit cast from BitcoinExtPubKey to ExtPubKey.
            </summary>
        </member>
        <member name="T:NBitcoin.ExtKey">
            <summary>
            A private Hierarchical Deterministic key
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Parse(System.String,NBitcoin.Network)">
            <summary>
            Parses the Base58 data (checking the network if specified), checks it represents the
            correct type of item, and then returns the corresponding ExtKey.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.Depth">
            <summary>
            Gets the depth of this extended key from the root key.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.Child">
            <summary>
            Gets the child number of this key (in reference to the parent).
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(NBitcoin.BitcoinExtPubKey,NBitcoin.BitcoinSecret)">
            <summary>
            Constructor. Reconstructs an extended key from the Base58 representations of 
            the public key and corresponding private key.  
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(NBitcoin.ExtPubKey,NBitcoin.Key)">
            <summary>
            Constructor. Creates an extended key from the public key and corresponding private key.  
            </summary>
            <remarks>
            <para>
            The ExtPubKey has the relevant values for child number, depth, chain code, and fingerprint.
            </para>
            </remarks>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(NBitcoin.Key,System.Byte[],System.Byte,NBitcoin.HDFingerprint,System.UInt32)">
            <summary>
            Constructor. Creates an extended key from the private key, and specified values for
            chain code, depth, fingerprint, and child number.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(NBitcoin.Key,System.Byte[])">
            <summary>
            Constructor. Creates an extended key from the private key, with the specified value
            for chain code. Depth, fingerprint, and child number, will have their default values.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor">
            <summary>
            Constructor. Creates a new extended key with a random 64 byte seed.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(System.String)">
            <summary>
            Constructor. Creates a new extended key from the specified seed bytes, from the given hex string.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Constructor. Creates a new extended key from the specified seed bytes.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.PrivateKey">
            <summary>
            Get the private key of this extended key.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Neuter">
            <summary>
            Create the public key from this key.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Derive(System.UInt32)">
            <summary>
            Derives a new extended key in the hierarchy as the given child number.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Derive(System.Int32,System.Boolean)">
            <summary>
            Derives a new extended key in the hierarchy as the given child number, 
            setting the high bit if hardened is specified.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Derive(NBitcoin.KeyPath)">
            <summary>
            Derives a new extended key in the hierarchy at the given path below the current key,
            by deriving the specified child at each step.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.GetWif(NBitcoin.Network)">
            <summary>
            Converts the extended key to the base58 representation, within the specified network.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.ToString(NBitcoin.Network)">
            <summary>
            Converts the extended key to the base58 representation, as a string, within the specified network.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.ScriptPubKey">
            <summary>
            Gets the script of the hash of the public key corresponding to the private key.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.IsHardened">
            <summary>
            Gets whether or not this extended key is a hardened child.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.GetParentExtKey(NBitcoin.ExtPubKey)">
            <summary>
            Recreates the private key of the parent from the private key of the child 
            combinated with the public key of the parent (hardened children cannot be
            used to recreate the parent).
            </summary>
        </member>
        <member name="T:NBitcoin.ExtPubKey">
            <summary>
            A public HD key
            </summary>
        </member>
        <member name="M:NBitcoin.ExtPubKey.#ctor(System.Byte[])">
            <summary>
            Constructor. Creates a new extended public key from the specified extended public key bytes.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtPubKey.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a new extended public key from the specified extended public key bytes.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtPubKey.#ctor(System.ReadOnlySpan{System.Byte})">
            <summary>
            Creates a new extended public key from the specified extended public key bytes.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtPubKey.#ctor(System.String)">
            <summary>
            Constructor. Creates a new extended public key from the specified extended public key bytes, from the given hex string.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtPubKey.ScriptPubKey">
            <summary>
            The P2PKH payment script
            </summary>
        </member>
        <member name="T:NBitcoin.KeyPath">
            <summary>
            Represent a path in the hierarchy of HD keys (BIP32)
            </summary>
        </member>
        <member name="M:NBitcoin.KeyPath.Parse(System.String)">
            <summary>
            Parse a KeyPath
            </summary>
            <param name="path">The KeyPath formated like 10/0/2'/3</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.KeyPath.TryParse(System.String,NBitcoin.KeyPath@)">
            <summary>
            Try Parse a KeyPath
            </summary>
            <param name="path">The KeyPath formated like 10/0/2'/3</param>
            <param name="keyPath">The successfully parsed Key path</param>
            <returns>True if the string is parsed successfully; otherwise false</returns>
        </member>
        <member name="P:NBitcoin.KeyPath.IsHardened">
            <summary>
            True if the last index in the path is hardened
            </summary>
        </member>
        <member name="M:NBitcoin.KeyPath.GetAddressKeyPath">
            <summary>
            Returns the longest non-hardened keypath to the leaf.
            For example, if the keypath is "49'/0'/0'/1/23", then the address key path is "1/23"
            </summary>
            <returns>Return the address key path</returns>
        </member>
        <member name="M:NBitcoin.KeyPath.GetAccountKeyPath">
            <summary>
            Returns the longest hardened keypath from the root.
            For example, if the keypath is "49'/0'/0'/1/23", then the account key path is "49'/0'/0'"
            </summary>
            <returns>Return the account key path</returns>
        </member>
        <member name="P:NBitcoin.KeyPath.IsHardenedPath">
            <summary>
            True if at least one index in the path is hardened
            </summary>
        </member>
        <member name="T:NBitcoin.RootedKeyPath">
            <summary>
            KeyPath with the fingerprint of the root it should derive from
            </summary>
        </member>
        <member name="M:NBitcoin.RootedKeyPath.GetAccountKeyPath">
            <summary>
            Returns the longest hardened keypath from the root.
            For example, if the keypath is "49'/0'/0'/1/23", then the account key path is "49'/0'/0'"
            </summary>
            <returns>Return the account key path</returns>
        </member>
        <member name="M:NBitcoin.RootedKeyPath.ToStringWithEmptyKeyPathAware">
            <summary>
            Mostly works same with `ToString()`, but if the `KeyPath` is empty, it just returns master finger print
            without `/` in the suffix
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.BitcoinEncryptedSecretEC.HashAddress(NBitcoin.BitcoinAddress)">
            <summary>
            Take the first four bytes of SHA256(SHA256(generatedaddress)) and call it addresshash.
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.BitcoinEncryptedSecret.GetKey(System.String)">
            <summary>
            Get the decrypted private key
            </summary>
            <param name="password">The password</param>
            <returns>The decrypted key</returns>
            <exception cref="T:System.Security.SecurityException">Invalid password</exception>
        </member>
        <member name="M:NBitcoin.BitcoinEncryptedSecret.TryGetKey(System.String,NBitcoin.Key@)">
            <summary>
            Get the decrypted private key
            </summary>
            <param name="password">The password</param>
            <param name="key">The decrypted key if successfull</param>
            <returns>True if successfull</returns>
        </member>
        <member name="T:NBitcoin.Mnemonic">
            <summary>
            A .NET implementation of the Bitcoin Improvement Proposal - 39 (BIP39)
            BIP39 specification used as reference located here: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
            Made by thashiznets@yahoo.com.au
            v1.0.1.1
            I â™¥ Bitcoin :)
            Bitcoin:1ETQjMkR1NNh4jwLuN5LxY7bMsHC9PUPSV
            </summary>
        </member>
        <member name="M:NBitcoin.Mnemonic.#ctor(NBitcoin.Wordlist,System.Byte[])">
            <summary>
            Generate a mnemonic
            </summary>
            <param name="wordList"></param>
            <param name="entropy"></param>
        </member>
        <member name="M:NBitcoin.Wordlist.#ctor(System.String[],System.Char,System.String)">
            <summary>
            Constructor used by inheritence only
            </summary>
            <param name="words">The words to be used in the wordlist</param>
        </member>
        <member name="M:NBitcoin.Wordlist.WordExists(System.String,System.Int32@)">
            <summary>
            Method to determine if word exists in word list, great for auto language detection
            </summary>
            <param name="word">The word to check for existence</param>
            <returns>Exists (true/false)</returns>
        </member>
        <member name="M:NBitcoin.Wordlist.GetWordAtIndex(System.Int32)">
            <summary>
            Returns a string containing the word at the specified index of the wordlist
            </summary>
            <param name="index">Index of word to return</param>
            <returns>Word</returns>
        </member>
        <member name="P:NBitcoin.Wordlist.WordCount">
            <summary>
            The number of all the words in the wordlist
            </summary>
        </member>
        <member name="F:NBitcoin.BIP9DeploymentsParameters.AlwaysActive">
            <summary>Special flag for timeout to indicate always active.</summary>
        </member>
        <member name="T:NBitcoin.BitcoinScriptAddress">
            <summary>
            Base58 representation of a script hash
            </summary>
        </member>
        <member name="T:NBitcoin.BitcoinAddress">
            <summary>
            Base58 representation of a bitcoin address
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinAddress.Create(System.String,NBitcoin.Network)">
            <summary>
            Detect whether the input base58 is a pubkey hash or a script hash
            </summary>
            <param name="str">The string to parse</param>
            <param name="expectedNetwork">The expected network to which it belongs</param>
            <returns>A BitcoinAddress or BitcoinScriptAddress</returns>
            <exception cref="T:System.FormatException">Invalid format</exception>
        </member>
        <member name="T:NBitcoin.BitcoinPubKeyAddress">
            <summary>
            Base58 representation of a pubkey hash and base class for the representation of a script hash
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinStream.ConsensusFactory">
            <summary>
            Set the format to use when serializing and deserializing consensus related types.
            </summary>
        </member>
        <member name="T:NBitcoin.BlockHeader">
            <summary>
            Nodes collect new transactions into a block, hash them into a hash tree,
            and scan through nonce values to make the block's hash satisfy proof-of-work
            requirements.  When they solve the proof-of-work, they broadcast the block
            to everyone and the block is added to the block chain.  The first transaction
            in the block is a special one that creates a new coin owned by the creator
            of the block.
            </summary>
        </member>
        <member name="M:NBitcoin.BlockHeader.PrecomputeHash(System.Boolean,System.Boolean)">
            <summary>
            Precompute the block header hash so that later calls to GetHash() will returns the precomputed hash
            </summary>
            <param name="invalidateExisting">If true, the previous precomputed hash is thrown away, else it is reused</param>
            <param name="lazily">If true, the hash will be calculated and cached at the first call to GetHash(), else it will be immediately</param>
        </member>
        <member name="M:NBitcoin.BlockHeader.UpdateTime(NBitcoin.Network,NBitcoin.ChainedBlock)">
            <summary>
            Set time to consensus acceptable value
            </summary>
            <param name="network">Network</param>
            <param name="prev">previous block</param>
        </member>
        <member name="M:NBitcoin.BlockHeader.UpdateTime(NBitcoin.Consensus,NBitcoin.ChainedBlock)">
            <summary>
            Set time to consensus acceptable value
            </summary>
            <param name="consensus">Consensus</param>
            <param name="prev">previous block</param>
        </member>
        <member name="M:NBitcoin.BlockHeader.UpdateTime(System.DateTimeOffset,NBitcoin.Consensus,NBitcoin.ChainedBlock)">
            <summary>
            Set time to consensus acceptable value
            </summary>
            <param name="now">The expected date</param>
            <param name="consensus">Consensus</param>
            <param name="prev">previous block</param>		
        </member>
        <member name="M:NBitcoin.BlockHeader.UpdateTime(System.DateTimeOffset,NBitcoin.Network,NBitcoin.ChainedBlock)">
            <summary>
            Set time to consensus acceptable value
            </summary>
            <param name="now">The expected date</param>
            <param name="network">Network</param>
            <param name="prev">previous block</param>		
        </member>
        <member name="M:NBitcoin.Block.GetCoinbaseHeight">
            <summary>
            Get the coinbase height as specified by the first tx input of this block (BIP 34)
            </summary>
            <returns>Null if block has been created before BIP34 got enforced, else, the height</returns>
        </member>
        <member name="M:NBitcoin.Block.WithOptions(NBitcoin.TransactionOptions)">
            <summary>
            Create a block with the specified option only. (useful for stripping data from a block)
            </summary>
            <param name="options">Options to keep</param>
            <returns>A new block with only the options wanted</returns>
        </member>
        <member name="M:NBitcoin.Block.Check">
            <summary>
            Check proof of work and merkle root
            </summary>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.BlockLocator">
            <summary>
            Compact representation of one's chain position which can be used to find forks with another chain
            </summary>
        </member>
        <member name="T:NBitcoin.BloomFilter">
            <summary>
            Used by SPV client, represent the set of interesting addresses tracked by SPV client with plausible deniability
            </summary>
        </member>
        <member name="T:NBitcoin.BuilderExtensions.BuilderExtension">
            <summary>
            Base extension class to derive from for extending the TransactionBuilder
            </summary>
        </member>
        <member name="M:NBitcoin.ChainBase.FindFork(NBitcoin.ChainBase)">
            <summary>
            Returns the first common block between two chains
            </summary>
            <param name="chain">The other chain</param>
            <returns>First common block or null</returns>
        </member>
        <member name="M:NBitcoin.ChainBase.FindFork(System.Collections.Generic.IEnumerable{NBitcoin.uint256})">
            <summary>
            Returns the first found block
            </summary>
            <param name="hashes">Hash to search for</param>
            <returns>First found block or null</returns>
        </member>
        <member name="M:NBitcoin.ChainBase.SetTip(NBitcoin.ChainedBlock)">
            <summary>
            Force a new tip for the chain
            </summary>
            <param name="pindex"></param>
            <returns>forking point</returns>
        </member>
        <member name="T:NBitcoin.ChainedBlock">
            <summary>
            A BlockHeader chained with all its ancestors
            </summary>
        </member>
        <member name="M:NBitcoin.ChainedBlock.StripCachedData">
            <summary>
            Free up some memory (cached HashBlock and ChainWork) at the price of efficiency
            </summary>
        </member>
        <member name="M:NBitcoin.ChainedBlock.StripHeader">
            <summary>
            Strip the Header to free up memory
            </summary>
        </member>
        <member name="P:NBitcoin.ChainedBlock.HasHeader">
            <summary>
            Returns true if this ChainedBlock has the underlying header
            </summary>
        </member>
        <member name="M:NBitcoin.ChainedBlock.TryGetHeader(NBitcoin.BlockHeader@)">
            <summary>
            Get the BlockHeader
            </summary>
            <param name="header">The block header</param>
            <returns>True if this ChainedBlock has block header</returns>
        </member>
        <member name="P:NBitcoin.ChainedBlock.Header">
            <summary>
            Get the underlying block header, throws if the Header is not present.
            </summary>
        </member>
        <member name="M:NBitcoin.ChainedBlock.GetChainWork(System.Boolean)">
            <summary>
            Get the value of the chain work
            </summary>
            <param name="cacheResult">If true, called GetChainWork on this block and future block will be faster, but this trade for space</param>
            <returns>The chain work value</returns>
        </member>
        <member name="M:NBitcoin.ChainedBlock.Validate(NBitcoin.Network)">
            <summary>
            Check PoW and that the blocks connect correctly
            </summary>
            <param name="network">The network being used</param>
            <returns>True if PoW is correct</returns>
        </member>
        <member name="M:NBitcoin.ChainedBlock.Validate(NBitcoin.Consensus)">
            <summary>
            Check PoW and that the blocks connect correctly
            </summary>
            <param name="consensus">The consensus being used</param>
            <returns>True if PoW is correct</returns>
        </member>
        <member name="M:NBitcoin.ChainedBlock.FindFork(NBitcoin.ChainedBlock)">
            <summary>
            Find first common block between two chains
            </summary>
            <param name="block">The tip of the other chain</param>
            <returns>First common block or null</returns>
        </member>
        <member name="M:NBitcoin.ICoin.GetScriptCode">
            <summary>
            Returns the script actually signed and executed
            </summary>
            <exception cref="T:System.InvalidOperationException">Additional information needed to get the ScriptCode</exception>
            <returns>The executed script</returns>
        </member>
        <member name="T:NBitcoin.ScriptCoin">
            <summary>
            Represent a coin which need a redeem script to be spent (P2SH or P2WSH)
            </summary>
        </member>
        <member name="M:NBitcoin.ScriptCoin.GetP2SHRedeem">
            <summary>
            Get the P2SH redeem script
            </summary>
            <returns>The P2SH redeem script or null if this coin is not P2SH.</returns>
        </member>
        <member name="M:NBitcoin.ScriptCoin.GetRedeemHash(NBitcoin.Script)">
            <summary>
            Returns the hash contained in the scriptPubKey (P2SH or P2WSH)
            </summary>
            <param name="scriptPubKey">The scriptPubKey</param>
            <returns>The hash of the scriptPubkey</returns>
        </member>
        <member name="P:NBitcoin.CompactSignature.RecoveryId">
            <summary>
            
            </summary>
        </member>
        <member name="P:NBitcoin.CompactSignature.Signature">
            <summary>
            The signature of 64 bytes
            </summary>
        </member>
        <member name="T:NBitcoin.ConcurrentChain">
            <summary>
            Thread safe class representing a chain of headers from genesis
            </summary>
        </member>
        <member name="M:NBitcoin.ConcurrentChain.SetTip(NBitcoin.ChainedBlock)">
            <summary>
            Force a new tip for the chain
            </summary>
            <param name="pindex"></param>
            <returns>forking point</returns>
        </member>
        <member name="T:NBitcoin.Crypto.Pbkdf2">
             <summary>
             Implements the PBKDF2 key derivation function.
             </summary>
             
             <example>
             <code title="Computing a Derived Key">
             using System.Security.Cryptography;
             using CryptSharp.Utility;
             
             // Compute a 128-byte derived key using HMAC-SHA256, 1000 iterations, and a given key and salt.
             byte[] derivedKey = Pbkdf2.ComputeDerivedKey(new HMACSHA256(key), salt, 1000, 128);
             </code>
             <code title="Creating a Derived Key Stream">
             using System.IO;
             using System.Security.Cryptography;
             using CryptSharp.Utility;
            
             // Create a stream using HMAC-SHA512, 1000 iterations, and a given key and salt.
             Stream derivedKeyStream = new Pbkdf2(new HMACSHA512(key), salt, 1000);
             </code>
             </example>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.#ctor(System.Security.Cryptography.KeyedHashAlgorithm,System.Byte[],System.Int32)">
            <summary>
            Creates a new PBKDF2 stream.
            </summary>
            <param name="hmacAlgorithm">
            </param>
            <param name="salt">
                The salt.
                A unique salt means a unique PBKDF2 stream, even if the original key is identical.
            </param>
            <param name="iterations">The number of iterations to apply.</param>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Read(System.Int32)">
            <summary>
            Reads from the derived key stream.
            </summary>
            <param name="count">The number of bytes to read.</param>
            <returns>Bytes from the derived key stream.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.ComputeDerivedKey(System.Security.Cryptography.KeyedHashAlgorithm,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Computes a derived key.
            </summary>
            <param name="hmacAlgorithm">
            </param>
            <param name="salt">
                The salt.
                A unique salt means a unique derived key, even if the original key is identical.
            </param>
            <param name="iterations">The number of iterations to apply.</param>
            <param name="derivedKeyLength">The desired length of the derived key.</param>
            <returns>The derived key.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Close">
            <summary>
            Closes the stream, clearing memory and disposing of the HMAC algorithm.
            </summary>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Flush">
            <exclude />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.SetLength(System.Int64)">
            <exclude />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Write(System.Byte[],System.Int32,System.Int32)">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.CanRead">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.CanSeek">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.CanWrite">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.Length">
            <summary>
            The maximum number of bytes that can be derived is 2^32-1 times the HMAC size.
            </summary>
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.Position">
            <summary>
            The position within the derived key stream.
            </summary>
        </member>
        <member name="T:NBitcoin.Crypto.Salsa20Core">
            <summary>
            Implements the Salsa20 hash function.
            </summary>
        </member>
        <member name="M:NBitcoin.Crypto.Salsa20Core.Compute(System.Int32,System.UInt32[],System.Int32,System.UInt32[],System.Int32)">
            <summary>
            Applies the Salsa20 hash function.
            It maps a 16 element input to an output of the same size.
            </summary>
            <param name="rounds">The number of rounds. SCrypt uses 8.</param>
            <param name="input">The input buffer.</param>
            <param name="inputOffset">The offset into the input buffer.</param>
            <param name="output">The output buffer.</param>
            <param name="outputOffset">The offset into the output buffer.</param>
        </member>
        <member name="T:NBitcoin.Crypto.SCrypt">
            <summary>
            Implements the SCrypt key derivation function.
            </summary>
        </member>
        <member name="M:NBitcoin.Crypto.SCrypt.ComputeDerivedKey(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32},System.Int32)">
            <summary>
            Computes a derived key.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique SCrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <param name="derivedKeyLength">The desired length of the derived key.</param>
            <returns>The derived key.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.SCrypt.GetEffectivePbkdf2Salt(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            The SCrypt algorithm creates a salt which it then uses as a one-iteration
            PBKDF2 key stream with SHA256 HMAC. This method lets you retrieve this intermediate salt.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique SCrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <returns>The effective salt.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.SCrypt.MFcrypt(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a derived key stream from which a derived key can be read.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique scrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <returns>The derived key stream.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.ECDSASignature.ToDER">
            What we get back from the signer are the two components of a signature, r and s. To get a flat byte stream
            of the type used by Bitcoin we have to encode them using DER encoding, which is just a way to pack the two
            components into a structure.
        </member>
        <member name="M:NBitcoin.Crypto.ECDSASignature.MakeCanonical">
            <summary>
            Enforce LowS on the signature
            </summary>
        </member>
        <member name="T:NBitcoin.Crypto.HashStream">
            <summary>
            Double SHA256 hash stream
            </summary>
        </member>
        <member name="T:NBitcoin.Crypto.BufferedHashStream">
            <summary>
            Unoptimized hash stream, bufferize all the data
            </summary>
        </member>
        <member name="M:NBitcoin.DataEncoders.Base58CheckEncoder.IsMaybeEncoded(System.String)">
            <summary>
            Fast check if the string to know if base58 str
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.DataEncoders.Base58Encoder.IsMaybeEncoded(System.String)">
            <summary>
            Fast check if the string to know if base58 str
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="P:NBitcoin.FeeRate.FeePerK">
            <summary>
            Fee per KB
            </summary>
        </member>
        <member name="P:NBitcoin.FeeRate.SatoshiPerByte">
            <summary>
            Satoshi per Byte
            </summary>
        </member>
        <member name="M:NBitcoin.FeeRate.GetFee(System.Int32)">
            <summary>
            Get fee for the size
            </summary>
            <param name="virtualSize">Size in bytes</param>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.IDestination">
            <summary>
            Represent any type which represent an underlying ScriptPubKey
            </summary>
        </member>
        <member name="T:NBitcoin.IAddressableDestination">
            <summary>
            Represent any type which represent an underlying ScriptPubKey which can be represented as an address
            </summary>
        </member>
        <member name="T:NBitcoin.IHDScriptPubKey">
            <summary>
            A IHDScriptPubKey represent an object which represent a tree of scriptPubKeys
            </summary>
        </member>
        <member name="M:NBitcoin.IpExtensions.ToEndpointString(System.Net.EndPoint)">
            <summary>
            Return {host}:{port} of this endpoint.
            </summary>
            <param name="endpoint"></param>
            <returns>{host}:{port} representation of this endpoint</returns>
        </member>
        <member name="M:NBitcoin.IpExtensions.AsOnionDNSEndpoint(System.Net.EndPoint)">
            <summary>
            Convert an onion cat IPEndpoint to an onion DnsEndpoint
            If endpoint is already an onion DnsEndpoint, return it.
            Else returns null.
            </summary>
            <param name="endpoint"></param>
            <returns>An onion DNS endpoint or null</returns>
        </member>
        <member name="M:NBitcoin.IpExtensions.TryConvertToOnionDNSEndpoint(System.Net.EndPoint,System.Net.DnsEndPoint@)">
            <summary>
            Convert an onion cat IPEndpoint to an onion DnsEndpoint
            If endpoint is already an onion DnsEndpoint, return it.
            If the endpoint is not an onion endpoint v2, return false.
            </summary>
            <param name="endpoint">The tor endpoint</param>
            <param name="dnsEndpoint">The onion dns enpoint</param>
            <returns>True if the onioncat address has been successfully parsed as a dns onion address</returns>
        </member>
        <member name="M:NBitcoin.IpExtensions.AsOnionCatIPEndpoint(System.Net.EndPoint)">
            <summary>
            Convert an onion DNS endpoint to an onioncat IpEndpoint
            If endpoint is already an onioncat IPEndpoint, return it.
            Else returns null.
            </summary>
            <param name="endpoint"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.IpExtensions.ResolveToIPEndpointsAsync(System.Net.EndPoint)">
            <summary>
            <para>Will properly convert <paramref name="endpoint"/> to IPEndpoint
            If <paramref name="endpoint"/> is a DNSEndpoint is an onion host (Tor v2), it will be converted into onioncat address
            else, a DNS resolution will be made and all resolved addresses will be returned</para>
            <para>If <paramref name="endpoint"/> is a IPEndpoint, it will be returned as-is.</para>
            You can pass any endpoint parsed by <see cref="M:NBitcoin.Utils.ParseEndpoint(System.String,System.Int32)"/>
            </summary>
            <param name="endpoint">The endpoint to convert to IPEndpoint</param>
            <exception cref="T:System.ArgumentNullException">The endpoint is null</exception>
            <exception cref="T:System.Net.Sockets.SocketException">An error is encountered when resolving the dns name.</exception>
            <exception cref="T:System.NotSupportedException">The endpoint passed can't be converted into an Ip (eg. An onion host which is not TorV2)</exception>
        </member>
        <member name="M:NBitcoin.IpExtensions.ResolveToIPEndpointsAsync(System.Net.EndPoint,NBitcoin.Protocol.IDnsResolver,System.Threading.CancellationToken)">
            <summary>
            <para>Will properly convert <paramref name="endpoint"/> to IPEndpoint
            If <paramref name="endpoint"/> is a DNSEndpoint is an onion host (Tor v2), it will be converted into onioncat address
            else, a DNS resolution will be made and all resolved addresses will be returned</para>
            <para>If <paramref name="endpoint"/> is a IPEndpoint, it will be returned as-is.</para>
            You can pass any endpoint parsed by <see cref="M:NBitcoin.Utils.ParseEndpoint(System.String,System.Int32)"/>
            </summary>
            <param name="endpoint">The endpoint to convert to IPEndpoint</param>
            <param name="dnsResolver">The DNS Resolver</param>
            <param name="cancellationToken">The cancellation token</param>
            <exception cref="T:System.ArgumentNullException">The endpoint is null</exception>
            <exception cref="T:System.Net.Sockets.SocketException">An error is encountered when resolving the dns name.</exception>
            <exception cref="T:System.NotSupportedException">The endpoint passed can't be converted into an Ip (eg. An onion host which is not TorV2)</exception>
        </member>
        <member name="T:NBitcoin.ITransactionRepository">
            <summary>
            Represent a transaction map
            </summary>
        </member>
        <member name="M:NBitcoin.Key.GetWif(NBitcoin.Network)">
            <summary>
            Same as GetBitcoinSecret
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="F:NBitcoin.WitScriptId._HashForLookUp">
            <summary>
            When we store internal ScriptId -> Script lookup, having another
            WitScriptId -> WitScript KVMap will complicate implementation. And require
            More space because WitScriptId is bigger than ScriptId. But if we use Hash160 as ID,
            It will cause a problem in case of p2sh-p2wsh because we must hold two scripts
            (witness program and witness script) with one ScriptId. So instead we use single-RIPEMD160
            This is the same way with how bitcoin core handles scripts internally.
            </summary>
        </member>
        <member name="T:NBitcoin.Logging.NullLogger">
            <summary>
            Minimalistic logger that does nothing.
            </summary>
        </member>
        <member name="M:NBitcoin.Logging.NullLogger.BeginScope``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:NBitcoin.Logging.NullLogger.IsEnabled(Microsoft.Extensions.Logging.LogLevel)">
            <inheritdoc />
        </member>
        <member name="M:NBitcoin.Logging.NullLogger.Log``1(Microsoft.Extensions.Logging.LogLevel,Microsoft.Extensions.Logging.EventId,``0,System.Exception,System.Func{``0,System.Exception,System.String})">
            <inheritdoc />
        </member>
        <member name="T:NBitcoin.Logging.NullScope">
            <summary>
            An empty scope without any logic
            </summary>
        </member>
        <member name="M:NBitcoin.Logging.NullScope.Dispose">
            <inheritdoc />
        </member>
        <member name="M:NBitcoin.MoneyBag.GetAmount(NBitcoin.OpenAsset.AssetId)">
            <summary>
            Get the Money corresponding to the input assetId
            </summary>
            <param name="assetId">The asset id, if null, will assume bitcoin amount</param>
            <returns>Never returns null, either the AssetMoney or Money if assetId is null</returns>
        </member>
        <member name="M:NBitcoin.MoneyBag.Split(System.Int32)">
            <summary>
            Split the MoneyBag in several one, without loss
            </summary>
            <param name="parts">The number of parts (must be more than 0)</param>
            <returns>The splitted money</returns>
        </member>
        <member name="M:NBitcoin.Money.TryParse(System.String,NBitcoin.Money@)">
            <summary>
            Parse a bitcoin amount (Culture Invariant)
            </summary>
            <param name="bitcoin"></param>
            <param name="nRet"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Parse(System.String)">
            <summary>
            Parse a bitcoin amount (Culture Invariant)
            </summary>
            <param name="bitcoin"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Abs">
            <summary>
            Get absolute value of the instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Split(System.Int32)">
            <summary>
            Split the Money in parts without loss
            </summary>
            <param name="parts">The number of parts (must be more than 0)</param>
            <returns>The splitted money</returns>
        </member>
        <member name="M:NBitcoin.Money.ToUnit(NBitcoin.MoneyUnit)">
            <summary>
            Convert Money to decimal (same as ToDecimal)
            </summary>
            <param name="unit"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.ToDecimal(NBitcoin.MoneyUnit)">
            <summary>
            Convert Money to decimal (same as ToUnit)
            </summary>
            <param name="unit"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.ToString">
            <summary>
            Returns a culture invariant string representation of Bitcoin amount
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.ToString(System.Boolean,System.Boolean)">
            <summary>
            Returns a culture invariant string representation of Bitcoin amount
            </summary>
            <param name="fplus">True if show + for a positive amount</param>
            <param name="trimExcessZero">True if trim excess zeros</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Almost(NBitcoin.Money,NBitcoin.Money)">
            <summary>
            Tell if amount is almost equal to this instance
            </summary>
            <param name="amount"></param>
            <param name="dust">more or less amount</param>
            <returns>true if equals, else false</returns>
        </member>
        <member name="M:NBitcoin.Money.Almost(NBitcoin.Money,System.Decimal)">
            <summary>
            Tell if amount is almost equal to this instance
            </summary>
            <param name="amount"></param>
            <param name="margin">error margin (between 0 and 1)</param>
            <returns>true if equals, else false</returns>
        </member>
        <member name="M:NBitcoin.Network.GetDefaultDataFolder(System.String)">
            <summary>
            Returns the default data directory of bitcoin correctly accross OS
            </summary>
            <param name="folderName">The name of the folder</param>
            <returns>The full path to the data directory of Bitcoin</returns>
        </member>
        <member name="M:NBitcoin.Network.CreateBitcoinAddress(System.String)">
            <summary>
            Create a bitcoin address from base58 data, return a BitcoinAddress or BitcoinScriptAddress
            </summary>
            <param name="base58">base58 address</param>
            <exception cref="T:System.FormatException">Invalid base58 address</exception>
            <returns>BitcoinScriptAddress, BitcoinAddress</returns>
        </member>
        <member name="M:NBitcoin.Network.GetNetwork(System.String)">
            <summary>
            Get network from name
            </summary>
            <param name="name">main,mainnet,testnet,test,testnet3,reg,regtest,sig,signet</param>
            <returns>The network or null of the name does not match any network</returns>
        </member>
        <member name="F:NBitcoin.BuriedDeployments.BIP34">
            <summary>
            Height in coinbase
            </summary>
        </member>
        <member name="F:NBitcoin.BuriedDeployments.BIP65">
            <summary>
            Height in OP_CLTV
            </summary>
        </member>
        <member name="F:NBitcoin.BuriedDeployments.BIP66">
            <summary>
            Strict DER signature
            </summary>
        </member>
        <member name="P:NBitcoin.Consensus.CoinType">
            <summary>
            Specify the BIP44 coin type for this network
            </summary>
        </member>
        <member name="P:NBitcoin.Consensus.LitecoinWorkCalculation">
            <summary>
            Specify using litecoin calculation for difficulty
            </summary>
        </member>
        <member name="M:NBitcoin.NetworkBuilder.BuildAndRegister">
            <summary>
            Create an immutable Network instance, and register it globally so it is queriable through Network.GetNetwork(string name) and Network.GetNetworks().
            </summary>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.NetworkStringParser">
            <summary>
            This class provide a hook for additional string format in altcoin network
            </summary>
        </member>
        <member name="M:NBitcoin.NetworkStringParser.TryParse``1(System.String,NBitcoin.Network,``0@)">
            <summary>
            Try to parse a string
            </summary>
            <param name="str">The string to parse</param>
            <param name="result">The result</param>
            <returns>True if it was possible to parse the string</returns>
        </member>
        <member name="T:NBitcoin.OpenAsset.AssetId">
            <summary>
            A unique Id for an asset
            </summary>
        </member>
        <member name="P:NBitcoin.OpenAsset.AssetMoney.Id">
            <summary>
            AssetId of the current amount
            </summary>
        </member>
        <member name="M:NBitcoin.OpenAsset.AssetMoney.Abs">
            <summary>
            Get absolute value of the instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.OpenAsset.AssetMoney.Split(System.Int32)">
            <summary>
            Split the Money in parts without loss
            </summary>
            <param name="parts">The number of parts (must be more than 0)</param>
            <returns>The splitted money</returns>
        </member>
        <member name="T:NBitcoin.OpenAsset.BitcoinAssetId">
            <summary>
            Base58 representation of an asset id
            </summary>
        </member>
        <member name="T:NBitcoin.OpenAsset.NullColoredTransactionRepository">
            <summary>
            A colored transaction repository which does not save ColoredTransaction
            </summary>
        </member>
        <member name="M:NBitcoin.PartialMerkleTree.Trim(NBitcoin.uint256[])">
            <summary>
            Remove superfluous branches
            </summary>
            <param name="transaction"></param>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.Payment.BitcoinUrlBuilder">
            <summary>
            https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki
            </summary>
        </member>
        <member name="M:NBitcoin.Policy.ITransactionPolicy.Check(NBitcoin.Transaction,NBitcoin.ICoin[])">
            <summary>
            Check if the given transaction violate the policy
            </summary>
            <param name="transaction">The transaction</param>
            <param name="spentCoins">The previous coins</param>
            <returns>Policy errors</returns>
        </member>
        <member name="T:NBitcoin.Policy.NotEnoughFundsPolicyError">
            <summary>
            Error when not enough funds are present for verifying or building a transaction
            </summary>
        </member>
        <member name="P:NBitcoin.Policy.NotEnoughFundsPolicyError.Missing">
            <summary>
            Amount of Money missing
            </summary>
        </member>
        <member name="P:NBitcoin.Policy.StandardTransactionPolicy.MaxTxFee">
            <summary>
            Safety check, if the FeeRate exceed this value, a policy error is raised
            </summary>
        </member>
        <member name="P:NBitcoin.Policy.StandardTransactionPolicy.CheckScriptPubKey">
            <summary>
            Check the standardness of scriptPubKey
            </summary>
        </member>
        <member name="T:NBitcoin.PrecomputedTransactionData">
            <summary>
            A data structure precomputing some hash values that are needed for all inputs to be signed in the transaction.
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.AddressManager">
            <summary>
            The AddressManager, keep a set of peers discovered on the network in cache can update their actual states.
            Replicate AddressManager of Bitcoin Core, the Buckets and BucketPosition are not guaranteed to be coherent with Bitcoin Core
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.AddressManager.AddAsync(System.Net.EndPoint,System.Net.IPAddress)">
            <summary>
            Will properly convert a endpoint to IPEndpoint
            If endpoint is a DNSEndpoint, a DNS resolution will be made and all addresses added
            If endpoint is a DNSEndpoint for onion, it will be converted into onioncat address
            If endpoint is an IPEndpoint it is added to AddressManager
            </summary>
            <param name="endpoint">The endpoint to add to the address manager</param>
            <param name="source">The source which advertized this endpoint (default: IPAddress.Loopback)</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Protocol.AddressManager.AddAsync(System.Net.EndPoint,System.Net.IPAddress,System.Threading.CancellationToken)">
            <summary>
            Will properly convert a endpoint to IPEndpoint
            If endpoint is a DNSEndpoint, a DNS resolution will be made and all addresses added
            If endpoint is a DNSEndpoint for onion, it will be converted into onioncat address
            If endpoint is an IPEndpoint it is added to AddressManager
            </summary>
            <param name="endpoint">The endpoint to add to the address manager</param>
            <param name="source">The source which advertized this endpoint (default: IPAddress.Loopback)</param>
            <param name="cancellationToken">The cancellationToken</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Protocol.AddressManager.Select">
            <summary>
            Choose an address to connect to.
            </summary>
            <returns>The network address of a peer, or null if none are found</returns>
        </member>
        <member name="M:NBitcoin.Protocol.AddressManager.GetAddr">
            <summary>
            Return a bunch of addresses, selected at random.
            </summary>
            <returns></returns>
        </member>
        <member name="F:NBitcoin.Protocol.Behaviors.AddressManagerBehaviorMode.None">
            <summary>
            Do not advertise or discover new peers
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.Behaviors.AddressManagerBehaviorMode.Advertize">
            <summary>
            Only advertise known peers
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.Behaviors.AddressManagerBehaviorMode.Discover">
            <summary>
            Only discover peers
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.Behaviors.AddressManagerBehaviorMode.AdvertizeDiscover">
            <summary>
            Advertise known peer and discover peer
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Behaviors.AddressManagerBehavior">
            <summary>
            The AddressManagerBehavior class will respond to getaddr and register advertised nodes from addr messages to the AddressManager.
            The AddressManagerBehavior will also receive feedback about connection attempt and success of discovered peers to the AddressManager, so it can be used later to find valid peer faster.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.AddressManagerBehavior.PeersToDiscover">
            <summary>
            The minimum number of peers to discover before trying to connect to a node using the AddressManager (Default: 1000)
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.BroadcastHub.BroadcastTransactionAsync(NBitcoin.Transaction)">
            <summary>
            Broadcast a transaction on the hub
            </summary>
            <param name="transaction">The transaction to broadcast</param>
            <returns>The cause of the rejection or null</returns>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.BroadcastHub.ManualBroadcast">
            <summary>
            If true, the user need to call BroadcastTransactions to ask to the nodes to broadcast it
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.BroadcastHub.BroadcastTransactions">
            <summary>
            Ask the nodes in the hub to broadcast transactions in the Hub manually
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Behaviors.ChainBehavior">
            <summary>
            The Chain Behavior is responsible for keeping a ConcurrentChain up to date with the peer, it also responds to getheaders messages.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.StripHeader">
            <summary>
            If true, the Chain maintained by the behavior with have its ChainedBlock with no Header (default: false)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.SkipPoWCheck">
            <summary>
            If true, skip PoW checks (default: false)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.CanSync">
            <summary>
            Keep the chain in Sync (Default : true)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.CanRespondToGetHeaders">
            <summary>
            Respond to getheaders messages (Default : true)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.Synching">
            <summary>
            Using for test, this might not be reliable
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.ChainBehavior.CheckAnnouncedBlocks">
            <summary>
            Check if any past blocks announced by this peer is in the invalid blocks list, and set InvalidHeaderReceived flag accordingly
            </summary>
            <returns>True if no invalid block is received</returns>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.AutoSync">
            <summary>
            Sync the chain as headers come from the network (Default : true)
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.ChainBehavior.TrySync">
            <summary>
            Asynchronously try to sync the chain
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.State.HighestValidatedPoW">
            <summary>
            ChainBehaviors sharing this state will not broadcast headers which are above HighestValidatedPoW
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Behaviors.NodesGroupBehavior">
            <summary>
            Maintain connection to a given set of nodes
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Behaviors.PingPongBehavior">
            <summary>
            The PingPongBehavior is responsible for firing ping message every PingInterval and responding with pong message, and close the connection if the Ping has not been completed after TimeoutInterval.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.PingPongBehavior.Mode">
            <summary>
            Whether the behavior send Ping and respond with Pong (Default : Both)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.PingPongBehavior.TimeoutInterval">
            <summary>
            Interval after which an unresponded Ping will result in a disconnection. (Default : 20 minutes)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.PingPongBehavior.PingInterval">
            <summary>
            Interval after which a Ping message is fired after the last received Pong (Default : 2 minutes)
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.PingPongBehavior.Probe">
            <summary>
            Send a ping asynchronously
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Behaviors.SlimChainBehavior">
            <summary>
            Behavior to keep a SlimChain in sync with the remote node
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.SocksSettingsBehavior.SocksEndpoint">
            <summary>
            If the socks endpoint to connect to
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.SocksSettingsBehavior.OnlyForOnionHosts">
            <summary>
            If the socks proxy is only used for Tor traffic (default: true)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.SocksSettingsBehavior.NetworkCredential">
            <summary>
            Credentials to connect to the SOCKS proxy (Use StreamIsolation instead if you want Tor isolation)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.SocksSettingsBehavior.StreamIsolation">
            <summary>
            Randomize the NetworkCredentials to the Socks proxy
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Connectors.DefaultEndpointConnector.AllowOnlyTorEndpoints">
            <summary>
            Connect to only hidden service nodes over Tor.
            Prevents connecting to clearnet nodes over Tor.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.DnsSocksResolver.NetworkCredential">
            <summary>
            Credentials to connect to the SOCKS proxy (Use StreamIsolation instead if you want Tor isolation)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.DnsSocksResolver.StreamIsolation">
            <summary>
            Randomize the NetworkCredentials to the Socks proxy
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Filters.INodeFilter">
            <summary>
            A NodeFilter can intercept messages received and sent.
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Filters.INodeFilter.OnReceivingMessage(NBitcoin.Protocol.IncomingMessage,System.Action)">
            <summary>
            Intercept a message before it can be processed by listeners
            </summary>
            <param name="message">The message</param>
            <param name="next">The rest of the pipeline</param>
        </member>
        <member name="M:NBitcoin.Protocol.Filters.INodeFilter.OnSendingMessage(NBitcoin.Protocol.Node,NBitcoin.Protocol.Payload,System.Action)">
            <summary>
            Intercept a message before it is sent to the peer
            </summary>
            <param name="node"></param>
            <param name="payload"></param>
            <param name="next">The rest of the pipeline</param>
        </member>
        <member name="F:NBitcoin.Protocol.Message._SkipMagic">
            <summary>
            When parsing, maybe Magic is already parsed
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddressType.Unroutable">
            Addresses from these networks are not publicly routable on the global Internet.
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddressType.Onion">
            TOR (v2 or v3)
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddressType.I2P">
            I2P
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddressType.Cjdns">
            CJDNS
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.AddrV2Format">
            see: https://github.com/bitcoin/bips/blob/master/bip-0155.mediawiki
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.Network.Unroutable">
            Addresses from these networks are not publicly routable on the global Internet.
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.Network.Onion">
            TOR (v2 or v3)
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.Network.I2P">
            I2P
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.Network.Cjdns">
            CJDNS
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.ADDR_IPV4_SIZE">
            Size of IPv4 address (in bytes).
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.ADDR_IPV6_SIZE">
            Size of IPv6 address (in bytes).
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.ADDR_TORV2_SIZE">
            Size of TORv2 address (in bytes).
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.ADDR_TORV3_SIZE">
            Size of TORv3 address (in bytes). This is the length of just the address
            as used in BIP155, without the checksum and the version byte.
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.ADDR_I2P_SIZE">
            Size of I2P address (in bytes).
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.ADDR_CJDNS_SIZE">
            Size of CJDNS address (in bytes).
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.TORV3_ADDR_CHECKSUM_LEN">
            Size of the TORv3 address checksum (in bytes)
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.TORV3_ADDR_VERSION_LEN">
            Size of the TORv3 address version number (in bytes)
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.IPV4_IN_IPV6_PREFIX">
            Prefix of an IPv6 address when it contains an embedded IPv4 address.
            Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.TORV2_IN_IPV6_PREFIX">
            Prefix of an IPv6 address when it contains an embedded TORv2 address.
            Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).
            Such dummy IPv6 addresses are guaranteed to not be publicly routable as they
            fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.
        </member>
        <member name="F:NBitcoin.Protocol.NetworkAddress.INTERNAL_IN_IPV6_PREFIX">
            Prefix of an IPv6 address when it contains an embedded "internal" address.
            Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).
            The prefix comes from 0xFD + SHA256("bitcoin")[0:5].
            Such dummy IPv6 addresses are guaranteed to not be publicly routable as they
            fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.
        </member>
        <member name="P:NBitcoin.Protocol.SynchronizeChainOptions.HashStop">
            <summary>
            Location until which synchronization should be stopped (default: null)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.SynchronizeChainOptions.SkipPoWCheck">
            <summary>
            Skip PoW check
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.SynchronizeChainOptions.StripHeaders">
            <summary>
            Strip headers from the retrieved chain
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Node.Connect(NBitcoin.Network,NBitcoin.Protocol.AddressManager,NBitcoin.Protocol.NodeConnectionParameters,System.Net.EndPoint[])">
            <summary>
            Connect to a random node on the network
            </summary>
            <param name="network">The network to connect to</param>
            <param name="addrman">The addrman used for finding peers</param>
            <param name="parameters">The parameters used by the found node</param>
            <param name="connectedEndpoints">The already connected endpoints, the new endpoint will be select outside of existing groups</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.Connect(NBitcoin.Network,NBitcoin.Protocol.NodeConnectionParameters,System.Net.EndPoint[],System.Func{System.Net.EndPoint,System.Byte[]})">
            <summary>
            Connect to a random node on the network
            </summary>
            <param name="network">The network to connect to</param>
            <param name="parameters">The parameters used by the found node, use AddressManagerBehavior.GetAddrman for finding peers</param>
            <param name="connectedEndpoints">The already connected endpoints, the new endpoint will be select outside of existing groups</param>
            <param name="getGroup">Group selector, by default NBicoin.IpExtensions.GetGroup</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.ConnectToLocal(NBitcoin.Network,NBitcoin.Protocol.NodeConnectionParameters)">
            <summary>
            Connect to the node of this machine
            </summary>
            <param name="network"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.SendMessageAsync(NBitcoin.Protocol.Payload)">
            <summary>
            Send a message to the peer asynchronously
            </summary>
            <param name="payload">The payload to send</param>
            <param name="System.OperationCanceledException.OperationCanceledException">The node has been disconnected</param>
        </member>
        <member name="M:NBitcoin.Protocol.Node.SendMessage(NBitcoin.Protocol.Payload,System.Threading.CancellationToken)">
            <summary>
            Send a message to the peer synchronously
            </summary>
            <param name="payload">The payload to send</param>
            <exception cref="T:System.ArgumentNullException">Payload is null</exception>
            <param name="System.OperationCanceledException.OperationCanceledException">The node has been disconnected, or the cancellation token has been set to canceled</param>
        </member>
        <member name="P:NBitcoin.Protocol.Node.Version">
            <summary>
            The negociated protocol version (minimum of supported version between MyVersion and the PeerVersion)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Node.Advertize">
            <summary>
            Send addr unsolicited message of the AddressFrom peer when passing to Handshaked state
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Node.RespondToHandShake(System.Threading.CancellationToken)">
            <summary>
            
            </summary>
            <param name="cancellation"></param>
        </member>
        <member name="P:NBitcoin.Protocol.Node.PreferredTransactionOptions">
            <summary>
            Transaction options we would like
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Node.SupportedTransactionOptions">
            <summary>
            Transaction options supported by the peer
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Node.PreferAddressV2">
            <summary>
            Transaction options supported by the peer
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Node.ActualTransactionOptions">
            <summary>
            Transaction options we prefer and which is also supported by peer
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Node.GetChain(NBitcoin.Protocol.SynchronizeChainOptions,System.Threading.CancellationToken)">
            <summary>
            Get the chain of headers from the peer (thread safe)
            </summary>
            <param name="options">The synchronization chain options</param>
            <param name="cancellationToken"></param>
            <returns>The chain of headers</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.GetSlimChain(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Get the chain of block hashes from the peer (thread safe)
            </summary>
            <param name="hashStop">Location until which synchronization should be stopped (default: null)</param>
            <param name="cancellationToken"></param>
            <returns>The chain of headers</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.GetChain(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Get the chain of headers from the peer (thread safe)
            </summary>
            <param name="hashStop">The highest block wanted</param>
            <param name="cancellationToken"></param>
            <returns>The chain of headers</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.SynchronizeChain(NBitcoin.ChainBase,NBitcoin.Protocol.SynchronizeChainOptions,System.Threading.CancellationToken)">
            <summary>
            Synchronize a given Chain to the tip of this node if its height is higher. (Thread safe)
            </summary>
            <param name="chain">The chain to synchronize</param>
            <param name="options">The synchronisation options</param>
            <param name="cancellationToken"></param>
            <returns>The chain of block retrieved</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.SynchronizeChain(NBitcoin.ChainBase,NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Synchronize a given Chain to the tip of this node if its height is higher. (Thread safe)
            </summary>
            <param name="chain">The chain to synchronize</param>
            <param name="hashStop">The location until which it synchronize</param>
            <param name="cancellationToken"></param>
            <returns>The chain of block retrieved</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.SynchronizeSlimChain(NBitcoin.SlimChain,NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Synchronize a given SlimChain to the tip of this node if its height is higher.
            </summary>
            <param name="chain">The chain to synchronize</param>
            <param name="hashStop">The location until which it synchronize</param>
            <param name="cancellationToken"></param>
            <returns>Task which finish when complete</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.CreateListener">
            <summary>
            Create a listener that will queue messages until disposed
            </summary>
            <returns>The listener</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if used on the listener's thread, as it would result in a deadlock</exception>
        </member>
        <member name="M:NBitcoin.Protocol.Node.GetMempoolTransactions(System.Threading.CancellationToken)">
            <summary>
            Retrieve transactions from the mempool
            </summary>
            <param name="cancellationToken">Cancellation token</param>
            <returns>Transactions in the mempool</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.GetMempoolTransactions(NBitcoin.uint256[],System.Threading.CancellationToken)">
            <summary>
            Retrieve transactions from the mempool by ids
            </summary>
            <param name="txIds">Transaction ids to retrieve</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns>The transactions, if a transaction is not found, then it is not returned in the array.</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.AddSupportedOptions(NBitcoin.Protocol.InventoryType)">
            <summary>
            Add supported option to the input inventory type
            </summary>
            <param name="inventoryType">Inventory type (like MSG_TX)</param>
            <returns>Inventory type with options (MSG_TX | MSG_WITNESS_FLAG)</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.PingPong(System.Threading.CancellationToken)">
            <summary>
            Emit a ping and wait the pong
            </summary>
            <param name="cancellation"></param>
            <returns>Latency</returns>
        </member>
        <member name="P:NBitcoin.Protocol.NodeConnectionParameters.Advertize">
            <summary>
            Send addr unsolicited message of the AddressFrom peer when passing to Handshaked state
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodeConnectionParameters.IsRelay">
            <summary>
            If true, the node will receive all incoming transactions if no bloomfilter are set
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodeServer.InboundNodeConnectionParameters">
            <summary>
            The parameters that will be cloned and applied for each node connecting to the NodeServer
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.NodesGroup.Connect">
            <summary>
            Start connecting asynchronously to remote peers
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.NodesGroup.Disconnect">
            <summary>
            Drop connection to all connected nodes
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.NodesGroup.Purge(System.String)">
            <summary>
            Asynchronously create a new set of nodes
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodesGroup.MaximumNodeConnection">
            <summary>
            The number of node that this behavior will try to maintain online (Default : 8)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodesGroup.AllowSameGroup">
            <summary>
            If false, the search process will do its best to connect to Node in different network group to prevent sybil attacks. (Default : false)
            If CustomGroupSelector is set, AllowSameGroup is ignored.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodesGroup.CustomGroupSelector">
            <summary>
            How to calculate a group of an ip, by default using NBitcoin.IpExtensions.GetGroup.
            Overrides AllowSameGroup.
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.NodesGroup.Dispose">
            <summary>
            Same as Disconnect
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.AddrPayload">
            <summary>
            An available peer address in the bitcoin network is announced (unsolicited or after a getaddr)
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.AddrV2Payload">
            <summary>
            An available peer address in the bitcoin network is announced (unsolicited or after a getaddrv2)
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.BlockPayload">
            <summary>
            A block received after being asked with a getdata message
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.CompactFilterPayload">
            <summary>
            Represents the p2p message payload used for sharing a block's compact filter.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.CompactFilterPayload.FilterType">
            <summary>
            Gets the Filter type for which headers are requested.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.CompactFilterPayload.FilterBytes">
            <summary>
            Gets the serialized compact filter for this block.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.CompactFilterPayload.BlockHash">
            <summary>
            Gets block hash of the Bitcoin block for which the filter is being returned.
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.FilterLoadPayload">
            <summary>
            Load a bloomfilter in the peer, used by SPV clients
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetAddrPayload">
            <summary>
            Ask for known peer addresses in the network
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetBlocksPayload">
            <summary>
            Ask for the block hashes (inv) that happened since BlockLocators
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.CompactFiltersQueryPayload">
            <summary>
            Represents the p2p message payload used for requesting a range of compact filter/headers.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.CompactFiltersQueryPayload.FilterType">
            <summary>
            Gets the Filter type for which headers are requested.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.CompactFiltersQueryPayload.StartHeight">
            <summary>
            Gets the height of the first block in the requested range.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.CompactFiltersQueryPayload.StopHash">
            <summary>
            Gets the hash of the last block in the requested range.
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetCompactFiltersPayload">
            <summary>
            Represents the p2p message payload used for requesting a range of compact filter.
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetCompactFilterHeadersPayload">
            <summary>
            Represents the p2p message payload used for requesting a range of compact filter headers.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.GetCompactFilterCheckPointPayload.FilterType">
            <summary>
            Gets the Filter type for which headers are requested.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.GetCompactFilterCheckPointPayload.StopHash">
            <summary>
            Gets the hash of the last block in the requested range.
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetDataPayload">
            <summary>
            Ask for transaction, block or merkle block
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetHeadersPayload">
            <summary>
            Ask block headers that happened since BlockLocators
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.HeadersPayload">
            <summary>
            Block headers received after a getheaders messages
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.InvPayload">
            <summary>
            Announce the hash of a transaction or block
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.MempoolPayload">
            <summary>
            Ask for the mempool, followed by inv messages
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.MerkleBlockPayload">
            <summary>
            A merkle block received after being asked with a getdata message
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.NotFoundPayload">
            <summary>
            A getdata message for an asked hash is not found by the remote peer
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.SendAddrV2Payload">
            <summary>
            Ask for known peer addresses in the network
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.TxPayload">
            <summary>
            Represents a transaction being sent on the network, is sent after being requested by a getdata (of Transaction or MerkleBlock) message.
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.Network">
            <summary>
            NODE_NETWORK means that the node is capable of serving the block chain. It is currently
            set by all Bitcoin Core nodes, and is unset by SPV clients or other peers that just want
            network services but don't provide them.
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.GetUTXO">
            <summary>
             NODE_GETUTXO means the node is capable of responding to the getutxo protocol request.
            Bitcoin Core does not support this but a patch set called Bitcoin XT does.
            See BIP 64 for details on how this is implemented.
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.NODE_BLOOM">
            <summary> NODE_BLOOM means the node is capable and willing to handle bloom-filtered connections.
            Bitcoin Core nodes used to support this by default, without advertising this bit,
            but no longer do as of protocol version 70011 (= NO_BLOOM_VERSION)
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.NODE_WITNESS">
            <summary> Indicates that a node can be asked for blocks and transactions including
            witness data. 
            </summary> 
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.NODE_NETWORK_LIMITED">
            <summary> NODE_NETWORK_LIMITED means the same as NODE_NETWORK with the limitation of only
            serving the last 288 (2 day) blocks
            See BIP159 for details on how this is implemented.
            </summary> 
        </member>
        <member name="P:NBitcoin.Protocol.SocketSettings.ReceiveTimeout">
            <summary>
            Set <see cref="P:System.Net.Sockets.Socket.ReceiveTimeout"/> value before connecting
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.SocketSettings.SendTimeout">
            <summary>
            Set <see cref="P:System.Net.Sockets.Socket.SendTimeout"/> value before connecting
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.SocketSettings.ReceiveBufferSize">
            <summary>
            Set <see cref="P:System.Net.Sockets.Socket.ReceiveBufferSize"/> value before connecting
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.SocketSettings.SendBufferSize">
            <summary>
            Set <see cref="P:System.Net.Sockets.Socket.SendBufferSize"/> value before connecting
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.PeerTooOld">
            <summary>
            Disconnect from peers older than this protocol version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportTimeAddress">
            <summary>
            nTime field added to CAddress, starting with this version;
            if possible, avoid requesting addresses nodes older than this
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportPingPong">
            <summary>
            BIP 0031, pong message, is enabled for all versions AFTER this one
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportMempoolQuery">
            <summary>
            "mempool" command, enhanced "getdata" behavior starts with this version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportNodeBloom">
            <summary>
            ! "filter*" commands are disabled without NODE_BLOOM after and including this version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportSendHeaders">
            <summary>
            ! "sendheaders" command and announcing blocks with headers starts with this version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportWitness">
            <summary>
            ! Version after which witness support potentially exists
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportCompactBlocks">
            <summary>
            short-id-based block download starts with this version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportCheckSum">
            <summary>
            Support checksum at p2p message level
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptPubKeyType.Legacy">
            <summary>
            Derive P2PKH addresses (P2PKH)
            Only use this for legacy code or coins not supporting segwit
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptPubKeyType.Segwit">
            <summary>
            Derive Segwit (Bech32) addresses (P2WPKH)
            This will result in the cheapest fees. This is the recommended choice.
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptPubKeyType.SegwitP2SH">
            <summary>
            Derive P2SH address of a Segwit address (P2WPKH-P2SH)
            Use this when you worry that your users do not support Bech address format.
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptPubKeyType.TaprootBIP86">
            <summary>
            Derive the taproot address of this pubkey following BIP86. This public key is used as the internal key, the output key is computed without script path. (The tweak is SHA256(internal_key))
            </summary>
        </member>
        <member name="M:NBitcoin.PubKey.#ctor(System.String)">
            <summary>
            Create a new Public key from string
            </summary>
        </member>
        <member name="M:NBitcoin.PubKey.#ctor(System.Byte[])">
            <summary>
            Create a new Public key from byte array
            </summary>
            <param name="bytes">byte array</param>
        </member>
        <member name="M:NBitcoin.PubKey.#ctor(System.ReadOnlySpan{System.Byte})">
            <summary>
            Create a new Public key from byte array
            </summary>
            <param name="bytes">byte array</param>
        </member>
        <member name="M:NBitcoin.PubKey.SanityCheck(System.Byte[])">
            <summary>
            Quick sanity check on public key format. (size + first byte)
            </summary>
            <param name="data">bytes array</param>
        </member>
        <member name="M:NBitcoin.PubKey.GetSharedPubkey(NBitcoin.Key)">
            <summary>
            Exchange shared secret through ECDH
            </summary>
            <param name="key">Private key</param>
            <returns>Shared pubkey</returns>
        </member>
        <member name="T:NBitcoin.RPC.GetBlockVerbosity">
            <summary>
            Verbosity option you can pass to `GetBlock` rpc call.
            If you want a raw block without metadata, (i.e. `0` verbosity for the rpc call) you should just call the method
            without this option.
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.GetBlockVerbosity.WithOnlyTxId">
            <summary>
            Verbosity `1` for the rpc call. Block itself will not be included in response if you specify this.
            However, txids in the block will be included in `TxIds` field in the response anyway.
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.GetBlockVerbosity.WithFullTx">
            <summary>
            Verbosity `2` for the rpc call. Use this if you want *both* full block and its metadata.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetBlockRPCResponse.NextBlockHash">
            <summary>
             This field exists only when the block is not on the tip.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetBlockRPCResponse.Block">
            <summary>
            This field exists only when you specified `WithFullTx` verbosity
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetTxOutResponse.BestBlock">
            <summary>
            the block hash
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetTxOutResponse.Confirmations">
            <summary>
            The number of confirmations
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetTxOutResponse.IsCoinBase">
            <summary>
            Coinbase or not
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetTxOutResponse.ScriptPubKeyType">
            <summary>
            The type, eg pubkeyhash
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ImportMultiAddress.ScriptPubKeyObject.IsAddress">
             <summary>
             Returns true if Address property is populated AND ScriptPubKey is not. If Address and ScriptPubKey are populated, ScriptPubKey takes precedence.
             </summary>
            
        </member>
        <member name="P:NBitcoin.RPC.ImportMultiAddress.Timestamp">
            <summary>
            Creation time of the key, keep null if this address has just been generated
            </summary>
        </member>
        <member name="T:NBitcoin.RPC.ImportMultiScriptPubKeyConverter">
            <summary>
            Custom JsonConverter to deal with loose type of scriptPubKey property in the ImportMulti method
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ListUnspentOptions.MinimumAmount">
            <summary>
            Minimum value of each UTXO
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ListUnspentOptions.MaximumAmount">
            <summary>
            Maximum value of each UTXO
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ListUnspentOptions.MaximumCount">
            <summary>
            Maximum number of UTXOs
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ListUnspentOptions.MinimumSumAmount">
            <summary>
            Minimum sum value of all UTXOs
            </summary>
        </member>
        <member name="T:NBitcoin.RPC.RestClient">
            <summary>
            Client class for the unauthenticated REST Interface
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RestClient.Network">
            <summary>
            Gets the <see cref="P:NBitcoin.RPC.RestClient.Network"/> instance for the client.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.#ctor(System.Uri)">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.RPC.RestClient"/> class.
            </summary>
            <param name="address">The rest API endpoint</param>
            <exception cref="T:System.ArgumentNullException">Null rest API endpoint</exception>
            <exception cref="T:System.ArgumentException">Invalid value for RestResponseFormat</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.#ctor(System.Uri,NBitcoin.Network)">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.RPC.RestClient"/> class.
            </summary>
            <param name="address">The rest API endpoint</param>
            <param name="network">The network to operate with</param>
            <exception cref="T:System.ArgumentNullException">Null rest API endpoint</exception>
            <exception cref="T:System.ArgumentException">Invalid value for RestResponseFormat</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlockAsync(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Gets the block.
            </summary>
            <param name="blockId">The block identifier.</param>
            <returns>Given a block hash (id) returns the requested block object.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlock(NBitcoin.uint256)">
            <summary>
            Gets the block.
            </summary>
            <param name="blockId">The block identifier.</param>
            <returns>Given a block hash (id) returns the requested block object.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetTransactionAsync(NBitcoin.uint256)">
            <summary>
            Gets a transaction.
            </summary>
            <param name="txId">The transaction identifier.</param>
            <returns>Given a transaction hash (id) returns the requested transaction object.</returns>
            <exception cref="T:System.ArgumentNullException">txId cannot be null</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetTransaction(NBitcoin.uint256)">
            <summary>
            Gets a transaction.
            </summary>
            <param name="txId">The transaction identifier.</param>
            <returns>Given a transaction hash (id) returns the requested transaction object.</returns>
            <exception cref="T:System.ArgumentNullException">txId cannot be null</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlockHeadersAsync(NBitcoin.uint256,System.Int32)">
            <summary>
            Gets blocks headers.
            </summary>
            <param name="blockId">The initial block identifier.</param>
            <param name="count">how many headers to get.</param>
            <returns>Given a block hash (blockId) returns as much block headers as specified.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">count must be greater or equal to one.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlockHeaders(NBitcoin.uint256,System.Int32)">
            <summary>
            Gets blocks headers.
            </summary>
            <param name="blockId">The initial block identifier.</param>
            <param name="count">how many headers to get.</param>
            <returns>Given a block hash (blockId) returns as much block headers as specified.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">count must be greater or equal to one.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetChainInfoAsync">
            <summary>
            Gets the chain information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetUnspentOutputsAsync(System.Collections.Generic.IEnumerable{NBitcoin.OutPoint},System.Boolean)">
            <summary>
            Gets unspect outputs.
            </summary>
            <param name="outPoints">The out points identifiers (TxIn-N).</param>
            <param name="checkMempool">if set to <c>true</c> [check mempool].</param>
            <returns>The unspent transaction outputs (UTXO) for the given outPoints.</returns>
            <exception cref="T:System.ArgumentNullException">outPoints cannot be null.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.#ctor(NBitcoin.Network)">
            <summary>
            Use default bitcoin parameters to configure a RPCClient.
            </summary>
            <param name="network">The network used by the node. Must not be null.</param>
        </member>
        <member name="P:NBitcoin.RPC.RPCClient.Capabilities">
            <summary>
            The RPC Capabilities of this RPCClient instance, this property will be set by a call to ScanRPCCapabilitiesAsync
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ScanRPCCapabilitiesAsync(System.Threading.CancellationToken)">
            <summary>
            Run several RPC function to scan the RPC capabilities, then set RPCClient.Capabilities
            </summary>
            <returns>The RPCCapabilities</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ScanRPCCapabilities">
            <summary>
            Run several RPC function to scan the RPC capabilities, then set RPCClient.RPCCapabilities
            </summary>
            <returns>The RPCCapabilities</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.#ctor(System.String,System.String,NBitcoin.Network)">
            <summary>
            Create a new RPCClient instance
            </summary>
            <param name="authenticationString">username:password, the content of the .cookie file, or cookiefile=pathToCookieFile</param>
            <param name="hostOrUri"></param>
            <param name="network"></param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.#ctor(System.String,System.Uri,NBitcoin.Network)">
            <summary>
            Create a new RPCClient instance
            </summary>
            <param name="authenticationString">username:password or the content of the .cookie file or null to auto configure</param>
            <param name="address"></param>
            <param name="network"></param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendBatch">
            <summary>
            Send all commands in one batch
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.CancelBatch">
            <summary>
            Cancel all commands
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.Uptime">
            <summary>
            Returns the total uptime of the server.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.UptimeAsync(System.Threading.CancellationToken)">
            <summary>
            Returns the total uptime of the server.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetStatusScanTxoutSetAsync(System.Threading.CancellationToken)">
            <summary>
            Get the progress report (in %) of the current scan
            </summary>
            <returns>The progress in %</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetStatusScanTxoutSet">
            <summary>
            Get the progress report (in %) of the current scan
            </summary>
            <returns>The progress in %</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.AbortScanTxoutSetAsync(System.Threading.CancellationToken)">
            <summary>
            Aborting the current scan
            </summary>
            <returns>Returns true when abort was successful</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.AbortScanTxoutSet">
            <summary>
            Aborting the current scan
            </summary>
            <returns>Returns true when abort was successful</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendBatchAsync(System.Threading.CancellationToken)">
            <summary>
            Send all commands in one batch
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RPCClient.AllowBatchFallback">
             <summary>
             Since bitcoin core 0.20, if a RPC batch request is made, and one of the request fails due
             to permission issue (whitelisting feature), the whole RPC Batch would fail, throwing a
             HttpRequestException.
            
             If we set AllowBatchFallback to true, we will fallback by sending all requests in the batch
             one by one.
             However, only use this for idempotent operations.
             When a batch operation fails because of permission issue, some of the requests in the batch
             may nevertheless have succeed without Bitcoin Core giving a clue about which one.
             </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetBlockAsync(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Get the a whole block
            </summary>
            <param name="blockId"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetBlock(NBitcoin.uint256)">
            <summary>
            Get the a whole block
            </summary>
            <param name="blockId"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetBlockFilter(NBitcoin.uint256)">
            <summary>
            Retrieve a BIP 157 content filter for a particular block.
            </summary>
            <param name="blockHash">The hash of the block.</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetBlockFilterAsync(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Retrieve a BIP 157 content filter for a particular block.
            </summary>
            <param name="blockHash">The hash of the block.</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetTxOut(NBitcoin.uint256,System.Int32,System.Boolean)">
            <summary>
            Returns details about an unspent transaction output.
            </summary>
            <param name="txid">The transaction id</param>
            <param name="index">vout number</param>
            <param name="includeMempool">Whether to include the mempool. Note that an unspent output that is spent in the mempool won't appear.</param>
            <returns>null if spent or never existed</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetTxOutAsync(NBitcoin.uint256,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Returns details about an unspent transaction output.
            </summary>
            <param name="txid">The transaction id</param>
            <param name="index">vout number</param>
            <param name="includeMempool">Whether to include the mempool. Note that an unspent output that is spent in the mempool won't appear.</param>
            <returns>null if spent or never existed</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetTxoutSetInfo">
            <summary>
            Returns statistics about the unspent transaction output (UTXO) set
            </summary>
            <returns>Parsed object containing all info</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetTransactions(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            GetTransactions only returns on txn which are not entirely spent unless you run bitcoinq with txindex=1.
            </summary>
            <param name="blockHash"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetRawTransaction(NBitcoin.uint256,System.Boolean)">
            <summary>
            getrawtransaction only returns on txn which are not entirely spent unless you run bitcoinq with txindex=1.
            </summary>
            <param name="txid"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.EstimateSmartFee(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode)">
            <summary>
            (>= Bitcoin Core v0.14) Get the estimated fee per kb for being confirmed in nblock
            If Capabilities is set and estimatesmartfee is not supported, will fallback on estimatefee
            </summary>
            <param name="confirmationTarget">Confirmation target in blocks (1 - 1008)</param>
            <param name="estimateMode">Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.</param>
            <returns>The estimated fee rate, block number where estimate was found</returns>
            <exception cref="T:NBitcoin.RPC.NoEstimationException">The Fee rate couldn't be estimated because of insufficient data from Bitcoin Core</exception>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.TryEstimateSmartFeeAsync(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode,System.Threading.CancellationToken)">
            <summary>
            (>= Bitcoin Core v0.14) Tries to get the estimated fee per kb for being confirmed in nblock
            If Capabilities is set and estimatesmartfee is not supported, will fallback on estimatefee
            </summary>
            <param name="confirmationTarget">Confirmation target in blocks (1 - 1008)</param>
            <param name="estimateMode">Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.</param>
            <returns>The estimated fee rate, block number where estimate was found or null</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.TryEstimateSmartFee(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode)">
            <summary>
            (>= Bitcoin Core v0.14) Tries to get the estimated fee per kb for being confirmed in nblock
            If Capabilities is set and estimatesmartfee is not supported, will fallback on estimatefee
            </summary>
            <param name="confirmationTarget">Confirmation target in blocks (1 - 1008)</param>
            <param name="estimateMode">Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.</param>
            <returns>The estimated fee rate, block number where estimate was found or null</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.EstimateSmartFeeAsync(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode,System.Threading.CancellationToken)">
            <summary>
            (>= Bitcoin Core v0.14) Get the estimated fee per kb for being confirmed in nblock
            If Capabilities is set and estimatesmartfee is not supported, will fallback on estimatefee
            </summary>
            <param name="confirmationTarget">Confirmation target in blocks (1 - 1008)</param>
            <param name="estimateMode">Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.</param>
            <returns>The estimated fee rate, block number where estimate was found</returns>
            <exception cref="T:NBitcoin.RPC.NoEstimationException">when fee couldn't be estimated</exception>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.EstimateSmartFeeImplAsync(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode,System.Threading.CancellationToken)">
            <summary>
            (>= Bitcoin Core v0.14)
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddress(NBitcoin.BitcoinAddress,NBitcoin.Money,NBitcoin.RPC.SendToAddressParameters,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="address">A P2PKH or P2SH address to which the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="parameters"></param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddress(NBitcoin.BitcoinAddress,NBitcoin.Money,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="address">A P2PKH or P2SH address to which the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddress(NBitcoin.Script,NBitcoin.Money,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="address">A P2PKH or P2SH address to which the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddressAsync(NBitcoin.Script,NBitcoin.Money,NBitcoin.RPC.SendToAddressParameters,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="address">A P2PKH or P2SH address to which the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="parameters"></param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddressAsync(NBitcoin.Script,NBitcoin.Money,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="scriptPubKey">The scriptPubKey where the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddress(NBitcoin.Script,NBitcoin.Money,NBitcoin.RPC.SendToAddressParameters,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="scriptPubKey">The scriptPubKey where the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="parameters"></param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddressAsync(NBitcoin.BitcoinAddress,NBitcoin.Money,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="address">A P2PKH or P2SH address to which the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddressAsync(NBitcoin.BitcoinAddress,NBitcoin.Money,NBitcoin.RPC.SendToAddressParameters,System.Threading.CancellationToken)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="address">A P2PKH or P2SH address to which the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="parameters"></param>
            <param name="cancellationToken"></param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.InvalidateBlock(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Permanently marks a block as invalid, as if it violated a consensus rule.
            </summary>
            <param name="blockhash">the hash of the block to mark as invalid</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.InvalidateBlockAsync(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Permanently marks a block as invalid, as if it violated a consensus rule.
            </summary>
            <param name="blockhash">the hash of the block to mark as invalid</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.AddPeerAddress(System.Net.IPAddress,System.Int32)">
            <summary>
            Add the address of a potential peer to the address manager. This RPC is for testing only.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.AddPeerAddressAsync(System.Net.IPAddress,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Add the address of a potential peer to the address manager. This RPC is for testing only.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetAddressInfo(NBitcoin.IDestination)">
            <summary>
            throws an error if an address is not from the wallet.
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetReceivedByAddress(NBitcoin.BitcoinAddress)">
            <summary>
            Returns the total amount received by the specified address in transactions with at
            least one (default) confirmations. It does not count coinbase transactions.
            </summary>
            <param name="address">The address whose transactions should be tallied.</param>
            <returns>The number of bitcoins received by the address, excluding coinbase transactions. May be 0.</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetReceivedByAddressAsync(NBitcoin.BitcoinAddress)">
            <summary>
            Returns the total amount received by the specified address in transactions with at
            least one (default) confirmations. It does not count coinbase transactions.
            </summary>
            <param name="address">The address whose transactions should be tallied.</param>
            <returns>The number of bitcoins received by the address, excluding coinbase transactions. May be 0.</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetReceivedByAddress(NBitcoin.BitcoinAddress,System.Int32)">
            <summary>
            Returns the total amount received by the specified address in transactions with the
            specified number of confirmations. It does not count coinbase transactions.
            </summary>
            <param name="confirmations">
            The minimum number of confirmations an externally-generated transaction must have before
            it is counted towards the balance. Transactions generated by this node are counted immediately.
            Typically, externally-generated transactions are payments to this wallet and transactions
            generated by this node are payments to other wallets. Use 0 to count unconfirmed transactions.
            Default is 1.
            </param>
            <returns>The number of bitcoins received by the address, excluding coinbase transactions. May be 0.</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetReceivedByAddressAsync(NBitcoin.BitcoinAddress,System.Int32)">
            <summary>
            Returns the total amount received by the specified address in transactions with the
            specified number of confirmations. It does not count coinbase transactions.
            </summary>
            <param name="confirmations">
            The minimum number of confirmations an externally-generated transaction must have before
            it is counted towards the balance. Transactions generated by this node are counted immediately.
            Typically, externally-generated transactions are payments to this wallet and transactions
            generated by this node are payments to other wallets. Use 0 to count unconfirmed transactions.
            Default is 1.
            </param>
            <returns>The number of bitcoins received by the address, excluding coinbase transactions. May be 0.</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ImportMultiAsync(NBitcoin.RPC.ImportMultiAddress[],System.Boolean,NBitcoin.ISigningRepository,System.Threading.CancellationToken)">
             <summary>
            
             </summary>
             <param name="addresses"></param>
             <param name="rescan"></param>
             <param name="signingRepository">If you specify this, This method tries to serialize OutputDescriptor with the private key (If there is any entry in the repository).</param>
             <returns></returns>
             <exception cref="T:NBitcoin.RPC.RPCException"></exception>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListUnspent">
            <summary>
            Returns an array of unspent transaction outputs belonging to this wallet.
            </summary>
            <remarks>
            <para>
            Note: as of Bitcoin Core 0.10.0, outputs affecting watch-only addresses will be returned;
            see the spendable field in the results.
            </para>
            </remarks>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListUnspent(System.Int32,System.Int32,NBitcoin.BitcoinAddress[])">
            <summary>
            Returns an array of unspent transaction outputs belonging to this wallet,
            specifying the minimum and maximum number of confirmations to include,
            and the list of addresses to include.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListUnspentAsync">
            <summary>
            Returns an array of unspent transaction outputs belonging to this wallet.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListUnspentAsync(System.Int32,System.Int32,NBitcoin.BitcoinAddress[])">
            <summary>
            Returns an array of unspent transaction outputs belonging to this wallet,
            specifying the minimum and maximum number of confirmations to include,
            and the list of addresses to include.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListUnspentAsync(NBitcoin.RPC.ListUnspentOptions,NBitcoin.BitcoinAddress[])">
            <summary>
            Returns an array of unspent transaction outputs belonging to this wallet,
            with query_options and the list of addresses to include.
            </summary>
            <param name="options">
            MinimumAmount - Minimum value of each UTXO
            MaximumAmount - Maximum value of each UTXO
            MaximumCount - Maximum number of UTXOs
            MinimumSumAmount - Minimum sum value of all UTXOs
            </param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.AbandonTransaction(NBitcoin.uint256)">
            <summary>
            Marks a transaction and all its in-wallet descendants as abandoned which will allow
            for their inputs to be respent.
            </summary>
            <param name="txId">the transaction id to be marked as abandoned.</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.AbandonTransactionAsync(NBitcoin.uint256)">
            <summary>
            Marks a transaction and all its in-wallet descendants as abandoned which will allow
            for their inputs to be respent.
            </summary>
            <param name="txId">the transaction id to be marked as abandoned.</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.WalletPassphrase(System.String,System.Int32)">
            <summary>
            The walletpassphrase RPC stores the wallet decryption key in memory for the indicated number of seconds.Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock time that overrides the old one.
            </summary>
            <param name="passphrase">The passphrase</param>
            <param name="timeout">Timeout in seconds</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.WalletPassphraseAsync(System.String,System.Int32)">
            <summary>
            The walletpassphrase RPC stores the wallet decryption key in memory for the indicated number of seconds.Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock time that overrides the old one.
            </summary>
            <param name="passphrase">The passphrase</param>
            <param name="timeout">Timeout in seconds</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SignRawTransaction(NBitcoin.Transaction)">
            <summary>
            Sign a transaction, if RPCClient.Capabilities is set, will call SignRawTransactionWithWallet if available
            </summary>
            <param name="tx">The transaction to be signed</param>
            <returns>The signed transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SignRawTransactionAsync(NBitcoin.Transaction)">
            <summary>
            Sign a transaction, if RPCClient.Capabilities is set, will call SignRawTransactionWithWallet if available
            </summary>
            <param name="tx">The transaction to be signed</param>
            <returns>The signed transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SignRawTransactionWithKey(NBitcoin.RPC.SignRawTransactionWithKeyRequest)">
            <summary>
            Sign a transaction
            </summary>
            <param name="request">The transaction to be signed</param>
            <returns>The signed transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SignRawTransactionWithKeyAsync(NBitcoin.RPC.SignRawTransactionWithKeyRequest,System.Threading.CancellationToken)">
            <summary>
            Sign a transaction
            </summary>
            <param name="request">The transaction to be signed</param>
            <returns>The signed transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SignRawTransactionWithWallet(NBitcoin.RPC.SignRawTransactionRequest)">
            <summary>
            Sign a transaction with wallet keys
            </summary>
            <param name="request">The transaction to be signed</param>
            <returns>The signed transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SignRawTransactionWithWalletAsync(NBitcoin.RPC.SignRawTransactionRequest,System.Threading.CancellationToken)">
            <summary>
            Sign a transaction with wallet keys
            </summary>
            <param name="request">The transaction to be signed</param>
            <returns>The signed transaction</returns>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.TransactionId">
            <summary>
            The transaction id (must be in mempool.)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.VirtualSizeBytes">
            <summary>
            Virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.Time">
            <summary>
            Local time transaction entered pool in seconds since 1 Jan 1970 GMT.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.Height">
            <summary>
            Block height when transaction entered pool.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.DescendantCount">
            <summary>
            Number of in-mempool descendant transactions (including this one.)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.DescendantVirtualSizeBytes">
            <summary>
            Virtual transaction size of in-mempool descendants (including this one.)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.AncestorCount">
            <summary>
            Number of in-mempool ancestor transactions (including this one.)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.AncestorVirtualSizeBytes">
            <summary>
            Virtual transaction size of in-mempool ancestors (including this one.)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.TransactionIdWithWitness">
            <summary>
            Hash of serialized transaction, including witness data.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.BaseFee">
            <summary>
            Transaction fee.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.ModifiedFee">
            <summary>
            Transaction fee with fee deltas used for mining priority.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.AncestorFees">
            <summary>
            Modified fees (see above) of in-mempool ancestors (including this one.)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.DescendantFees">
            <summary>
            Modified fees (see above) of in-mempool descendants (including this one.)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.Depends">
            <summary>
            Unconfirmed transactions used as inputs for this transaction.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.MempoolEntry.SpentBy">
            <summary>
            Unconfirmed transactions spending outputs from this transaction.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SendToAddressParameters.Comment">
            <summary>
            A locally-stored (not broadcast) comment assigned to this transaction. Default is no comment.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SendToAddressParameters.CommentTo">
            <summary>
            A locally-stored (not broadcast) comment assigned to this transaction. Meant to be used for describing who the payment was sent to. Default is no comment.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SendToAddressParameters.SubstractFeeFromAmount">
            <summary>
            The fee will be deducted from the amount being sent. The recipient will receive less bitcoins than you enter in the amount field. Default is false.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SendToAddressParameters.Replaceable">
            <summary>
            Allow this transaction to be replaced by a transaction with higher fees. 
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SendToAddressParameters.ConfTarget">
            <summary>
            Confirmation target in blocks
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SendToAddressParameters.EstimateMode">
            <summary>
            The fee estimate mode
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SendToAddressParameters.FeeRate">
            <summary>
            Specify a fee rate in sat/vB.
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RPCCredentialString.UseDefault">
            <summary>
            Use default connection settings of the chain
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RPCCredentialString.WalletName">
            <summary>
            Name of the wallet in multi wallet mode
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RPCCredentialString.CookieFile">
            <summary>
            Path to cookie file
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RPCCredentialString.UserPassword">
            <summary>
            Username and password
            </summary>
        </member>
        <member name="T:NBitcoin.RPC.RPCErrorCode">
            <summary>
            RPC error code thrown by the <see cref="T:NBitcoin.RPC.RPCClient"/>
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_INVALID_REQUEST">
            <summary>
            RPC_INVALID_REQUEST is internally mapped to HTTP_BAD_REQUEST (400).
            It should not be used for application-layer errors. 
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_METHOD_NOT_FOUND">
            <summary>
            RPC_METHOD_NOT_FOUND is internally mapped to HTTP_NOT_FOUND (404).
            It should not be used for application-layer errors.
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_INTERNAL_ERROR">
            <summary>
            RPC_INTERNAL_ERROR should only be used for genuine errors in bitcoind
            (for example datadir corruption).
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_MISC_ERROR">
            <summary>
            std::exception thrown in command handling
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_FORBIDDEN_BY_SAFE_MODE">
            <summary>
            Server is in safe mode, and command is not allowed in safe mode
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_TYPE_ERROR">
            <summary>
            Unexpected type was passed as parameter
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_INVALID_ADDRESS_OR_KEY">
            <summary>
            Invalid address or key
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_OUT_OF_MEMORY">
            <summary>
            Ran out of memory during operation
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_INVALID_PARAMETER">
            <summary>
            Invalid, missing or duplicate parameter
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_DATABASE_ERROR">
            <summary>
            Database error
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_DESERIALIZATION_ERROR">
            <summary>
            Error parsing or validating structure in raw format
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_VERIFY_ERROR">
            <summary>
            General error during transaction or block submission
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_VERIFY_REJECTED">
            <summary>
            Transaction or block was rejected by network rules
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_VERIFY_ALREADY_IN_CHAIN">
            <summary>
            Transaction already in chain
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_IN_WARMUP">
            <summary>
            Client still warming up
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_METHOD_DEPRECATED">
            <summary>
            RPC method is deprecated
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_NOT_CONNECTED">
            <summary>
            Bitcoin is not connected
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_IN_INITIAL_DOWNLOAD">
            <summary>
            Still downloading initial blocks
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_NODE_ALREADY_ADDED">
            <summary>
            Node is already added
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_NODE_NOT_ADDED">
            <summary>
            Node has not been added before
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_NODE_NOT_CONNECTED">
            <summary>
            Node to disconnect not found in connected nodes
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_INVALID_IP_OR_SUBNET">
            <summary>
            Invalid IP/Subnet
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_P2P_DISABLED">
            <summary>
            No valid connection manager instance found
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_ERROR">
            <summary>
            Unspecified problem with wallet (key not found etc.)
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_INSUFFICIENT_FUNDS">
            <summary>
            Not enough funds in wallet or account
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_INVALID_ACCOUNT_NAME">
            <summary>
            Invalid account name
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_KEYPOOL_RAN_OUT">
            <summary>
            Keypool ran out, call keypoolrefill first
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_UNLOCK_NEEDED">
            <summary>
            Enter the wallet passphrase with walletpassphrase first
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_PASSPHRASE_INCORRECT">
            <summary>
            The wallet passphrase entered was incorrect
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_WRONG_ENC_STATE">
            <summary>
            Command given in wrong wallet encryption state (encrypting an encrypted wallet etc.)
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_ENCRYPTION_FAILED">
            <summary>
            Failed to encrypt the wallet
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_ALREADY_UNLOCKED">
            <summary>
            Wallet is already unlocked
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_NOT_FOUND">
            <summary>
            Invalid wallet specified
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_NOT_SPECIFIED">
            <summary>
            No wallet specified (error when there are multiple wallets loaded)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ScanTxoutDescriptor.Begin">
            <summary>
            The range of HD chain indexes to explore
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ScanTxoutDescriptor.End">
            <summary>
            The range of HD chain indexes to explore
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionRequest.PrevTx.RedeemScript">
            <summary>
            Redeem script (required for P2SH or P2WSH)
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionRequest.PreviousTransactions">
            <summary>
            An json array of previous dependent transaction outputs
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionRequest.Transaction">
            <summary>
            The transaction to sign
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionRequest.SigHash">
            <summary>
            The signature hash type
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionWithKeyRequest.PrivateKeys">
            <summary>
            A json array of base58-encoded private keys for signing
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionResponse.ScriptError.OutPoint">
            <summary>
            The outpoint referenced
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionResponse.SignedTransaction">
            <summary>
            The raw transaction with signature
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionResponse.Complete">
            <summary>
            If the transaction has a complete set of signatures
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.SignRawTransactionResponse.Errors">
            <summary>
            Script verification errors (if there are any)
            </summary>
        </member>
        <member name="T:NBitcoin.ScriptVerify">
            <summary>
            Script verification flags
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.P2SH">
            <summary>
            Evaluate P2SH subscripts (softfork safe, BIP16).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.StrictEnc">
            <summary>
            Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
            Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be
            +
            skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.DerSig">
            <summary>
            Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.LowS">
            <summary>
            Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure
            (softfork safe, BIP62 rule 5).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.NullDummy">
            <summary>
            verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.SigPushOnly">
            <summary>
            Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.MinimalData">
            <summary>
            Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct
            pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating
            any other push causes the script to fail (BIP62 rule 3).
            In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).
            (softfork safe)
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.DiscourageUpgradableNops">
             <summary>
             Discourage use of NOPs reserved for upgrades (NOP1-10)
            
             Provided so that nodes can avoid accepting or mining transactions
             containing executed NOP's whose meaning may change after a soft-fork,
             thus rendering the script invalid; with this flag set executing
             discouraged NOPs fails the script. This verification flag will never be
             a mandatory flag applied to scripts in a block. NOPs that are not
             executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.
             </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.CleanStack">
            <summary>
            Require that only a single stack element remains after evaluation. This changes the success criterion from
            "At least one stack element must remain, and when interpreted as a boolean, it must be true" to
            "Exactly one stack element must remain, and when interpreted as a boolean, it must be true".
            (softfork safe, BIP62 rule 6)
            Note: CLEANSTACK should never be used without P2SH.
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.CheckLockTimeVerify">
             <summary>
             Verify CHECKLOCKTIMEVERIFY
            
             See BIP65 for details.
             </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.CheckSequenceVerify">
            <summary>
            See BIP68 for details.
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.Witness">
            <summary>
            Support segregated witness
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.DiscourageUpgradableWitnessProgram">
            <summary>
            Making v2-v16 witness program non-standard
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.MinimalIf">
            <summary>
            Segwit script only: Require the argument of OP_IF/NOTIF to be exactly 0x01 or empty vector
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.NullFail">
            <summary>
            Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.WitnessPubkeyType">
            <summary>
            Public keys in segregated witness scripts must be compressed
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.ForkId">
            <summary>
            Some altcoins like BCash and BGold requires ForkId inside the sigHash
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NBitcoin.ScriptVerify.Taproot" -->
        <member name="F:NBitcoin.ScriptVerify.DiscourageUpgradableTaprootVersion">
            <summary>
            Making unknown Taproot leaf versions non-standard
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.Mandatory">
             <summary>
             Mandatory script verification flags that all new blocks must comply with for
             them to be valid. (but old blocks may not comply with) Currently just P2SH,
             but in the future other flags may be added, such as a soft-fork to enforce
             strict DER encoding.
            
             Failing one of these tests may trigger a DoS ban - see CheckInputs() for
             details.
             </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.Standard">
            <summary>
            Standard script verification flags that standard transactions will comply
            with. However scripts violating these flags may still be present in valid
            blocks and we must accept those blocks.
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.Consensus">
            <summary>
            Strict consensus script verification flags that are checked by the Bitcoin Core
            consensus library before validating the transaction.
            </summary>
        </member>
        <member name="T:NBitcoin.SigHash">
            <summary>
            Signature hash types/flags
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.All">
            <summary>
            All outputs are signed
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.None">
            <summary>
            No outputs as signed
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.Single">
            <summary>
            Only the output with the same index as this input is signed
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.AnyoneCanPay">
            <summary>
            If set, no inputs, except this, are part of the signature
            </summary>
        </member>
        <member name="T:NBitcoin.TaprootSigHash">
            <summary>
            Signature hash types/flags for taproot transactions
            </summary>
        </member>
        <member name="F:NBitcoin.TaprootSigHash.All">
            <summary>
            All outputs are signed
            </summary>
        </member>
        <member name="F:NBitcoin.TaprootSigHash.None">
            <summary>
            No outputs as signed
            </summary>
        </member>
        <member name="F:NBitcoin.TaprootSigHash.Single">
            <summary>
            Only the output with the same index as this input is signed
            </summary>
        </member>
        <member name="F:NBitcoin.TaprootSigHash.AnyoneCanPay">
            <summary>
            If set, no inputs, except this, are part of the signature
            </summary>
        </member>
        <member name="T:NBitcoin.OpcodeType">
            <summary>
            Script opcodes
            </summary>
        </member>
        <member name="F:NBitcoin.HashVersion.Taproot">
            <summary>
            Key spend
            </summary>
        </member>
        <member name="F:NBitcoin.HashVersion.Tapscript">
            <summary>
            Script spend
            </summary>
        </member>
        <member name="M:NBitcoin.Script.ExtractScriptCode(System.Int32)">
            <summary>
            Extract the ScriptCode delimited by the codeSeparatorIndex th OP_CODESEPARATOR.
            </summary>
            <param name="codeSeparatorIndex">Index of the OP_CODESEPARATOR, or -1 for fetching the whole script</param>
            <returns></returns>
        </member>
        <member name="P:NBitcoin.Script.PaymentScript">
            <summary>
            Get the P2SH scriptPubKey of this script
            </summary>
        </member>
        <member name="M:NBitcoin.Script.GetSignerAddress(NBitcoin.Network)">
            <summary>
            Extract P2SH or P2PKH address from scriptSig
            </summary>
            <param name="network">The network</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.GetSigner">
            <summary>
            Extract P2SH or P2PKH id from scriptSig
            </summary>
            <returns>The network</returns>
        </member>
        <member name="M:NBitcoin.Script.GetDestinationAddress(NBitcoin.Network)">
            <summary>
            Extract P2SH/P2PKH/P2WSH/P2WPKH/P2TR address from scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.GetDestination">
            <summary>
            Extract P2SH/P2PKH/P2WSH/P2WPKH/P2TR id from scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.GetDestinationPublicKeys">
            <summary>
            Extract public keys if this script is a multi sig or pay to pub key scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.ToBytes">
            <summary>
            Get script byte array
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.ToBytes(System.Boolean)">
            <summary>
            Get script byte array
            </summary>
            <param name="unsafe">if false, returns a copy of the internal byte array</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.VerifyScriptConsensus(System.Byte[],System.UInt32,System.Byte[],System.UInt32,System.UInt32,NBitcoin.ScriptVerify,NBitcoin.Script.BitcoinConsensusError@)">
            Returns 1 if the input nIn of the serialized transaction pointed to by
            txTo correctly spends the scriptPubKey pointed to by scriptPubKey under
            the additional constraints specified by flags.
            If not NULL, err will contain an error/success code for the operation
        </member>
        <member name="M:NBitcoin.ScriptEvaluationContext.CScriptNum.#ctor(System.Int64)">
            Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.
            The semantics are subtle, though: operands must be in the range [-2^31 +1...2^31 -1],
            but results may overflow (and are valid as long as they are not used in a subsequent
            numeric operation). CScriptNum enforces those semantics by storing results as
            an int64 and allowing out-of-range values to be returned as a vector of bytes but
            throwing an exception if arithmetic is done or the result is interpreted as an integer.
        </member>
        <member name="T:NBitcoin.ContextStack`1">
            <summary>
            ContextStack is used internally by the bitcoin script evaluator. This class contains
            operations not typically available in a "pure" Stack class, as example:
            Insert, Swap, Erase and Top (Peek w/index)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NBitcoin.ContextStack`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.ContextStack`1"/> class.
            </summary>
        </member>
        <member name="M:NBitcoin.ContextStack`1.#ctor(NBitcoin.ContextStack{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.ContextStack`1"/>
            base on another stack. This is for copy/clone.
            </summary>
            <param name="stack">The stack.</param>
        </member>
        <member name="P:NBitcoin.ContextStack`1.Count">
            <summary>
            Gets the number of items in the stack.
            </summary>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Push(`0)">
            <summary>
            Pushes the specified item on the stack.
            </summary>
            <param name="item">The item to by pushed.</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Pop">
            <summary>
            Pops this element in top of the stack.
            </summary>
            <returns>The element in top of the stack</returns>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Clear(System.Int32)">
            <summary>
            Pops as many items as specified.
            </summary>
            <param name="n">The number of items to be poped</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Cannot remove more elements</exception>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Top(System.Int32)">
            <summary>
            Returns the i-th element from the top of the stack.
            </summary>
            <param name="i">The i-th index.</param>
            <returns>the i-th element from the top of the stack</returns>
            <exception cref="T:System.IndexOutOfRangeException">topIndex</exception>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Swap(System.Int32,System.Int32)">
            <summary>
            Swaps the specified i and j elements in the stack.
            </summary>
            <param name="i">The i-th index.</param>
            <param name="j">The j-th index.</param>
            <exception cref="T:System.IndexOutOfRangeException">
            i or  j
            </exception>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item in the specified position.
            </summary>
            <param name="position">The position.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Remove(System.Int32)">
            <summary>
            Removes the i-th item.
            </summary>
            <param name="from">The item position</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Remove(System.Int32,System.Int32)">
            <summary>
            Removes items from the i-th position to the j-th position.
            </summary>
            <param name="from">The item position</param>
            <param name="to">The item position</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.AsInternalArray">
            <summary>
            Returns a copy of the internal array.
            </summary>
            <returns>A copy of the internal array</returns>
        </member>
        <member name="T:NBitcoin.ContextStack`1.Enumerator">
            <summary>
            Implements a reverse enumerator for the ContextStack
            </summary>
        </member>
        <member name="M:NBitcoin.Scripting.OutputDescriptor.TryExpand(System.UInt32,NBitcoin.ISigningRepository,NBitcoin.ISigningRepository,System.Collections.Generic.List{NBitcoin.Script}@,System.Collections.Generic.IDictionary{System.UInt32,NBitcoin.ExtPubKey})">
            <summary>
            Expand descriptor into actual scriptPubKeys.
            </summary>
            <param name="pos">position index to expand</param>
            <param name="privateKeyProvider">provider to inject private keys in case of hardened derivation</param>
            <param name="repo">repository to which to put resulted information.</param>
            <param name="outputScripts">resulted scriptPubKey</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.OutputDescriptor.TryExpand(System.UInt32,System.Func{NBitcoin.KeyId,NBitcoin.Key},NBitcoin.ISigningRepository,System.Collections.Generic.List{NBitcoin.Script}@,System.Collections.Generic.IDictionary{System.UInt32,NBitcoin.ExtPubKey})">
            <summary>
            Expand descriptor into actual scriptPubKeys.
            TODO: cache
            </summary>
            <param name="pos">position index to expand</param>
            <param name="privateKeyProvider">provider to inject private keys in case of hardened derivation</param>
            <param name="repo">repository to which to put resulted information.</param>
            <param name="outputScripts">resulted scriptPubKey</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.OutputDescriptor.GetScriptPubKeyType">
            <summary>
            Infer the address type for that descriptor.
            When it is impossible, just return null.
            e.g. In case of descriptors those are agnostic to the actual scriptpubkey format (e.g. "multi"),
            it just returns null.
            </summary>
            <returns></returns>
        </member>
        <member name="F:NBitcoin.Scripting.OutputDescriptor.CHECKSUM_CHARSET">
            The character set for the checksum itself (same as bech32). 
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.String(System.String)">
            <summary>
            Parse a string of characters.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Text(NBitcoin.Scripting.Parser.Parser{System.Char,System.Collections.Generic.IEnumerable{System.Char}})">
            <summary>
            Convert a stream of characters to a string.
            </summary>
            <param name="characters"></param>
            <returns></returns>
        </member>
        <member name="F:NBitcoin.Scripting.Parser.Parse.Number">
            <summary>
            Parse a number.
            </summary>
        </member>
        <member name="F:NBitcoin.Scripting.Parser.Parse.Decimal">
            <summary>
            Parse a decimal number with separator '.'.
            </summary>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.XMany``2(NBitcoin.Scripting.Parser.Parser{``0,``1})">
            <summary>
            Parse a stream of elements, failing if any element is only partially parsed.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T">The type of element to parse.</typeparam>
            <param name="parser">A parser that matches a single element.</param>
            <returns>A <see cref="T:NBitcoin.Scripting.Parser.Parser`1"/> that matches the sequence.</returns>
            <remarks>
            <para>
            Using <seealso cref="M:NBitcoin.Scripting.Parser.Parse.XMany``2(NBitcoin.Scripting.Parser.Parser{``0,``1})"/> may be preferable to <seealso cref="M:NBitcoin.Scripting.Parser.Parse.Many``2(NBitcoin.Scripting.Parser.Parser{``0,``1})"/>
            where the first character of each match identified by <paramref name="parser"/>
            is sufficient to determine whether the entire match should succeed. The X*
            methods typically give more helpful errors and are easier to debug than their
            unqualified counterparts.
            </para>
            </remarks>
            <seealso cref="M:NBitcoin.Scripting.Parser.Parse.XOr``2(NBitcoin.Scripting.Parser.Parser{``0,``1},NBitcoin.Scripting.Parser.Parser{``0,``1})"/>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.AtLeastOnce``2(NBitcoin.Scripting.Parser.Parser{``0,``1})">
            <summary>
            TryParse a stream of elements with at least one item.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.XAtLeastOnce``2(NBitcoin.Scripting.Parser.Parser{``0,``1})">
            <summary>
            TryParse a stream of elements with at least one item. Except the first
            item, all other items will be matched with the <code>XMany</code> operator.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Return``2(``1)">
            <summary>
            Lift to a parser monad world
            </summary>
            <param name="v"></param>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Select``3(NBitcoin.Scripting.Parser.Parser{``0,``1},System.Func{``1,``2})">
            <summary>
            Take the result of parsing, and project it onto a different domain.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <param name="parser"></param>
            <param name="convert"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Ref``2(System.Func{NBitcoin.Scripting.Parser.Parser{``0,``1}})">
            <summary>
            Refer to another parser indirectly. This allows circular compile-time dependency between parsers.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="reference"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.XOr``2(NBitcoin.Scripting.Parser.Parser{``0,``1},NBitcoin.Scripting.Parser.Parser{``0,``1})">
            <summary>
            Parse first, if it succeeds, return first, otherwise try second.
            Assumes that the first parsed character will determine the parser chosen (see Try).
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Concat``2(NBitcoin.Scripting.Parser.Parser{``0,System.Collections.Generic.IEnumerable{``1}},NBitcoin.Scripting.Parser.Parser{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Concatenate two streams of elements.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Return``3(NBitcoin.Scripting.Parser.Parser{``0,``1},``2)">
            <summary>
            Version of Return with simpler inline syntax.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <param name="parser"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Except``3(NBitcoin.Scripting.Parser.Parser{``0,``1},NBitcoin.Scripting.Parser.Parser{``0,``2})">
            <summary>
            Attempt parsing only if the <paramref name="except"/> parser fails.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <param name="parser"></param>
            <param name="except"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Until``3(NBitcoin.Scripting.Parser.Parser{``0,``1},NBitcoin.Scripting.Parser.Parser{``0,``2})">
            <summary>
            Parse a sequence of items until a terminator is reached.
            Returns the sequence, discarding the terminator.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <param name="parser"></param>
            <param name="until"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.Where``2(NBitcoin.Scripting.Parser.Parser{``0,``1},System.Func{``1,System.Boolean})">
            <summary>
            Succeed if the parsed value matches predicate.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="parser"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.SelectMany``4(NBitcoin.Scripting.Parser.Parser{``0,``1},System.Func{``1,NBitcoin.Scripting.Parser.Parser{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            Monadic combinator Then, adapted for Linq comprehension syntax.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="parser"></param>
            <param name="selector"></param>
            <param name="projector"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.ChainOperator``3(NBitcoin.Scripting.Parser.Parser{``0,``2},NBitcoin.Scripting.Parser.Parser{``0,``1},System.Func{``2,``1,``1,``1})">
            <summary>
            Chain a left-associative operator.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="TOp"></typeparam>
            <param name="op"></param>
            <param name="operand"></param>
            <param name="apply"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.XChainOperator``3(NBitcoin.Scripting.Parser.Parser{``0,``2},NBitcoin.Scripting.Parser.Parser{``0,``1},System.Func{``2,``1,``1,``1})">
            <summary>
            Chain a left-associative operator.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="TOp"></typeparam>
            <param name="op"></param>
            <param name="operand"></param>
            <param name="apply"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.ChainRightOperator``3(NBitcoin.Scripting.Parser.Parser{``0,``2},NBitcoin.Scripting.Parser.Parser{``0,``1},System.Func{``2,``1,``1,``1})">
            <summary>
            Chain a right-associative operator.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="TOp"></typeparam>
            <param name="op"></param>
            <param name="operand"></param>
            <param name="apply"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.Parse.XChainRightOperator``3(NBitcoin.Scripting.Parser.Parser{``0,``2},NBitcoin.Scripting.Parser.Parser{``0,``1},System.Func{``2,``1,``1,``1})">
            <summary>
            Chain a right-associative operator.
            </summary>
            <typeparam name="TToken"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="TOp"></typeparam>
            <param name="op"></param>
            <param name="operand"></param>
            <param name="apply"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.ParserExtension.TryParse``1(NBitcoin.Scripting.Parser.Parser{System.Char,``0},System.String,NBitcoin.Network)">
            <summary>
            Tries to parse the input without throwing an exception.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="parser">The parser.</param>
            <param name="input">The input.</param>
            <returns>The result of the parser</returns>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.ParserExtension.Parse``1(NBitcoin.Scripting.Parser.Parser{System.Char,``0},System.String,NBitcoin.Network)">
            <summary>
            Parses the specified input string.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="parser">The parser.</param>
            <param name="input">The input.</param>
            <returns>The result of the parser.</returns>
            <exception cref="T:NBitcoin.Scripting.Parser.ParsingException">It contains the details of the parsing error.</exception>
        </member>
        <member name="T:NBitcoin.Scripting.Parser.ParsingException">
            <summary>
            Represents an error that occurs during parsing.
            </summary>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.ParsingException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.Scripting.Parser.ParsingException" /> class.
            </summary>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.ParsingException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.Scripting.Parser.ParsingException" /> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.ParsingException.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.Scripting.Parser.ParsingException" /> class with a specified error message
            and the position where the error occured.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="position">The position where the error occured.</param>
        </member>
        <member name="M:NBitcoin.Scripting.Parser.ParsingException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.Scripting.Parser.ParsingException" /> class with a specified error message 
            and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, 
            or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="P:NBitcoin.Scripting.Parser.ParsingException.Position">
            <summary>
            Gets the position of the parsing failure if one is available; otherwise, null.
            </summary>
        </member>
        <member name="T:NBitcoin.Scripting.PubKeyProvider">
            <summary>
            Public key objects in descriptors.
            </summary>
        </member>
        <member name="T:NBitcoin.Scripting.PubKeyProvider.Origin">
            <summary>
            Wrapper for other pubkey provider which contains (parent key finger print + relative derivation path to inner Pubkey provider)
            </summary>
        </member>
        <member name="M:NBitcoin.Scripting.PubKeyProvider.TryGetPubKey(System.UInt32,System.Func{NBitcoin.KeyId,NBitcoin.Key},NBitcoin.RootedKeyPath@,NBitcoin.PubKey@)">
             <summary>
            
             </summary>
             <param name="pos"></param>
             <param name="privateKeyProvider">In case of the hardend derivation.
             You must give private key by this to derive child</param>
             <param name="keyOriginInfo"></param>
             <param name="pubkey"></param>
             <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NBitcoin.Scripting.PubKeyProvider.TryGetPrivateString(NBitcoin.ISigningRepository,System.String@)" -->
        <member name="M:NBitcoin.Secp256k1.ECMultContext.Mult(NBitcoin.Secp256k1.GEJ@,NBitcoin.Secp256k1.Scalar@,System.Nullable{NBitcoin.Secp256k1.Scalar}@)">
            <summary>
            Double multiply: R = na*A + ng*G
            (secp256k1_ecmult)
            </summary>
            <param name="a"></param>
            <param name="na"></param>
            <param name="ng"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.ECMultContext.MultBatch(System.Nullable{NBitcoin.Secp256k1.Scalar}@,System.ReadOnlySpan{NBitcoin.Secp256k1.Scalar},System.ReadOnlySpan{NBitcoin.Secp256k1.GE},NBitcoin.Secp256k1.MultBatchOptions)">
            <summary>
            R = inp_g_sc * G + SUM(scalars[i] * points[i])
            </summary>
            <param name="inp_g_sc">The scalar for point G</param>
            <param name="scalars">The scalars</param>
            <param name="points">The points</param>
            <param name="options">Advanced options</param>
            <returns>R</returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.ECMultContext.MultBatch(System.Nullable{NBitcoin.Secp256k1.Scalar}@,System.ReadOnlySpan{NBitcoin.Secp256k1.Scalar},System.ReadOnlySpan{NBitcoin.Secp256k1.GE},NBitcoin.Secp256k1.ECMultiImplementation)">
            <summary>
            R = inp_g_sc * G + SUM(scalars[i] * points[i])
            </summary>
            <param name="inp_g_sc">The scalar for point G</param>
            <param name="scalars">The scalars</param>
            <param name="points">The points</param>
            <param name="implementation">The implementation</param>
        </member>
        <member name="M:NBitcoin.Secp256k1.ECMultContext.MultBatch(System.Nullable{NBitcoin.Secp256k1.Scalar}@,System.ReadOnlySpan{NBitcoin.Secp256k1.Scalar},System.ReadOnlySpan{NBitcoin.Secp256k1.GE})">
            <summary>
            R = inp_g_sc * G + SUM(scalars[i] * points[i])
            </summary>
            <param name="inp_g_sc">The scalar for point G</param>
            <param name="scalars">The scalars</param>
            <param name="points">The points</param>
        </member>
        <member name="M:NBitcoin.Secp256k1.ECMultContext.MultBatch(System.ReadOnlySpan{NBitcoin.Secp256k1.Scalar},System.ReadOnlySpan{NBitcoin.Secp256k1.GE})">
            <summary>
            R = SUM(scalars[i] * points[i])
            </summary>
            <param name="scalars">The scalars</param>
            <param name="points">The points</param>
        </member>
        <member name="M:NBitcoin.Secp256k1.ECMultContext.secp256k1_ecmult_odd_multiples_table_globalz_windowa(System.Span{NBitcoin.Secp256k1.GE},NBitcoin.Secp256k1.FE@,NBitcoin.Secp256k1.GEJ@)">
            Fill a table 'pre' with precomputed odd multiples of a.
            
              There are two versions of this function:
              - secp256k1_ecmult_odd_multiples_table_globalz_windowa which brings its
                resulting point set to a single constant Z denominator, stores the X and Y
                coordinates as ge_storage points in pre, and stores the global Z in rz.
                It only operates on tables sized for WINDOW_A wnaf multiples.
              - secp256k1_ecmult_odd_multiples_table_storage_var, which converts its
                resulting point set to actually affine points, and stores those in pre.
                It operates on tables of any size, but uses heap-allocated temporaries.
            
              To compute a*P + b*G, we compute a table for P using the first function,
              and for G using the second (which requires an inverse, but it only needs to
              happen once).
        </member>
        <member name="M:NBitcoin.Secp256k1.ECMultContext.secp256k1_pippenger_bucket_window(System.Int32)">
            Returns optimal bucket_window (number of bits of a scalar represented by a
            set of buckets) for a given number of points.
        </member>
        <member name="M:NBitcoin.Secp256k1.ECMultContext.secp256k1_ecmult_odd_multiples_table(System.Int32,System.Span{NBitcoin.Secp256k1.GEJ},System.Span{NBitcoin.Secp256k1.FE},NBitcoin.Secp256k1.GEJ@)">
            Fill a table 'prej' with precomputed odd multiples of a. Prej will contain
            the values [1*a,3*a,...,(2*n-1)*a], so it space for n values. zr[0] will
            contain prej[0].z / a.z. The other zr[i] values = prej[i].z / prej[i-1].z.
            Prej's Z values are undefined, except for the last value.
        </member>
        <member name="M:NBitcoin.Secp256k1.ECMultGenContext.MultGen(NBitcoin.Secp256k1.Scalar@)">
            <summary>
            Multiply with the generator: R = a*G
            (secp256k1_ecmult_gen)
            </summary>
            <param name="a">A scalar to multiply to G</param>
            <returns>The result of a*G</returns>
        </member>
        <member name="T:NBitcoin.Secp256k1.INonceFunction">
            A pointer to a function to deterministically generate a nonce.
            
             Returns: 1 if a nonce was successfully generated. 0 will cause signing to fail.
             Out:     nonce32:   pointer to a 32-byte array to be filled by the function.
             In:      msg32:     the 32-byte message hash being verified (will not be NULL)
                      key32:     pointer to a 32-byte secret key (will not be NULL)
                      algo16:    pointer to a 16-byte array describing the signature
                                 algorithm (will be NULL for ECDSA for compatibility).
                      data:      Arbitrary data pointer that is passed through.
                      attempt:   how many iterations we have tried to find a nonce.
                                 This will almost always be 0, but different attempt values
                                 are required to result in a different nonce.
            
             Except for test cases, this function should compute some cryptographic hash of
             the message, the algorithm, the key and the attempt.
        </member>
        <member name="M:NBitcoin.Secp256k1.ECPrivKey.CreatePubKey">
            <summary>
            Compute the public key for a secret key.
            </summary>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed</exception>
            <returns>A public key</returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.ECPrivKey.TweakAdd(System.ReadOnlySpan{System.Byte})">
            <summary>
            Tweak a private key by adding tweak to it.
            secp256k1_ec_privkey_tweak_add
            </summary>
            <param name="tweak">32 bytes tweak</param>
            <exception cref="T:System.ArgumentException">If the tweak is not 32 bytes or if the tweak was out of range (chance of around 1 in 2^128 for uniformly random 32-byte arrays, or if the resulting private key would be invalid(only when the tweak is the complement of the private key)</exception>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed</exception>
            <returns>A tweaked private key</returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.ECPrivKey.TryTweakAdd(System.ReadOnlySpan{System.Byte},NBitcoin.Secp256k1.ECPrivKey@)">
            <summary>
            Tweak a private key by adding tweak to it.
            secp256k1_ec_privkey_tweak_add
            </summary>
            <param name="tweak">32 bytes tweak</param>
            <param name="tweakedPrivKey">False If the tweak is not 32 bytes or if the tweak was out of range (chance of around 1 in 2^128 for uniformly random 32-byte arrays, or if the resulting private key would be invalid(only when the tweak is the complement of the private key)</param>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed</exception>
            <returns>A tweaked private key</returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.ECPrivKey.TweakMul(System.ReadOnlySpan{System.Byte})">
            <summary>
            Tweak a private key by multiplying it by a tweak value.
            secp256k1_ec_privkey_tweak_mul
            </summary>
            <param name="tweak">32 bytes tweak</param>
            <param name="tweakedPrivKey">False If the tweak is not 32 bytes or if the tweak was out of range (chance of around 1 in 2^128 for uniformly random 32-byte arrays, or if the resulting private key would be invalid(only when the tweak is the complement of the private key)</param>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed</exception>
            <returns>A tweaked private key</returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.ECPrivKey.TryTweakMul(System.ReadOnlySpan{System.Byte},NBitcoin.Secp256k1.ECPrivKey@)">
            <summary>
            Tweak a private key by multiplying it by a tweak value.
            secp256k1_ec_privkey_tweak_mul
            </summary>
            <param name="tweak">32 bytes tweak</param>
            <param name="tweakedPrivKey">False If the tweak is not 32 bytes or if the tweak was out of range (chance of around 1 in 2^128 for uniformly random 32-byte arrays, or if the resulting private key would be invalid(only when the tweak is the complement of the private key)</param>
            <exception cref="T:System.ObjectDisposedException">This instance has been disposed</exception>
            <returns>A tweaked private key</returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.ECPrivKey.SignBIP340(System.ReadOnlySpan{System.Byte})">
            <summary>
            Create a non deterministic BIP340 schnorr signature. With Auxiliary random data taken from secure RNG.
            </summary>
            <param name="msg32">32 bytes message to sign</param>
            <returns>A schnorr signature</returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.ECPrivKey.SignBIP340(System.ReadOnlySpan{System.Byte},System.ReadOnlyMemory{System.Byte})">
            <summary>
            Create a deterministic BIP340 schnorr signature. With auxiliary random data passed in parameter.
            </summary>
            <param name="msg32">32 bytes message to sign</param>
            <param name="auxData32">Auxiliary random data</param>
            <returns>A schnorr signature</returns>
        </member>
        <member name="F:NBitcoin.Secp256k1.ECPubKey.order_as_fe">
            Group order for secp256k1 defined as 'n' in "Standards for Efficient Cryptography" (SEC2) 2.7.1
            sage: for t in xrange(1023, -1, -1):
               ..   p = 2**256 - 2**32 - t
               ..   if p.is_prime():
               ..     print '%x'%p
               ..     break
             'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'
            sage: a = 0
            sage: b = 7
            sage: F = FiniteField (p)
            sage: '%x' % (EllipticCurve ([F (a), F (b)]).order())
             'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'
        </member>
        <member name="F:NBitcoin.Secp256k1.ECPubKey.p_minus_order">
            Difference between field and order, values 'p' and 'n' values defined in
            "Standards for Efficient Cryptography" (SEC2) 2.7.1.
            sage: p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
            sage: a = 0
            sage: b = 7
            sage: F = FiniteField (p)
            sage: '%x' % (p - EllipticCurve ([F (a), F (b)]).order())
             '14551231950b75fc4402da1722fc9baee'
        </member>
        <member name="M:NBitcoin.Secp256k1.ECPubKey.TryCombine(NBitcoin.Secp256k1.Context,System.Collections.Generic.IEnumerable{NBitcoin.Secp256k1.ECPubKey},NBitcoin.Secp256k1.ECPubKey@)">
            <summary>
            The original function name is `secp256k1_ec_pubkey_combine`
            </summary>
        </member>
        <member name="M:NBitcoin.Secp256k1.ECXOnlyPubKey.WriteToSpan(System.Span{System.Byte})">
            <summary>
            Write the 32 bytes of the X value of the public key to output32
            </summary>
            <param name="output32"></param>
        </member>
        <member name="M:NBitcoin.Secp256k1.ECXOnlyPubKey.CheckIsTweakedWith(NBitcoin.Secp256k1.ECXOnlyPubKey,System.ReadOnlySpan{System.Byte},System.Boolean)">
            <summary>
            Checks that a tweaked pubkey is the result of calling AddTweak on internalPubKey and tweak32
            </summary>
            <param name="internalPubKey">The internal PubKey</param>
            <param name="tweak32">The tweak to add to internalPubKey</param>
            <param name="expectedParity">The expected parity</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.FE.CONST(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Create a field element from uint, most significative uint first. (big endian)
            </summary>
            <param name="d7"></param>
            <param name="d6"></param>
            <param name="d5"></param>
            <param name="d4"></param>
            <param name="d3"></param>
            <param name="d2"></param>
            <param name="d1"></param>
            <param name="d0"></param>
            <returns>A field element</returns>
        </member>
        <member name="F:NBitcoin.Secp256k1.GE.SECP256K1_TAG_PUBKEY_EVEN">
            Prefix byte used to tag various encoded curvepoints for specific purposes 
        </member>
        <member name="P:NBitcoin.Secp256k1.GE.Infinity">
            Generator for secp256k1, value 'g' defined in
            "Standards for Efficient Cryptography" (SEC2) 2.7.1.
        </member>
        <member name="M:NBitcoin.Secp256k1.GE.ToEvenY(System.Boolean@)">
            <summary>
            Keeps a group element as is if it has an even Y and otherwise negates it.
            parity is set to 0 in the former case and to 1 in the latter case.
            Requires that the coordinates of r are normalized.
            </summary>
        </member>
        <member name="M:NBitcoin.Secp256k1.GE.ToEvenY">
            <summary>
            Keeps a group element as is if it has an even Y and otherwise negates it.
            Requires that the coordinates of r are normalized.
            </summary>
        </member>
        <member name="M:NBitcoin.Secp256k1.GE.MultConst(NBitcoin.Secp256k1.Scalar@,System.Int32)">
            <summary>
            Multiply this group element by q in constant time
            (secp256k1_ecmult_const)
            </summary>
            <param name="q">The scalar to multiply to</param>
            <param name="bits">Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q` plus one because we internally sometimes add 2 to the number during the WNAF conversion.</param>
            <returns></returns>
        </member>
        <member name="F:NBitcoin.Secp256k1.ECMultiImplementation.Auto">
            <summary>
            Pick the optimum algorithm depending on the size of the batch
            </summary>
        </member>
        <member name="P:NBitcoin.Secp256k1.MultBatchOptions.PippengerThreshold">
            <summary>
            The number of scalars until the Auto implementation pick pippenger algorithm over strauss (Default: 88)
            </summary>
        </member>
        <member name="P:NBitcoin.Secp256k1.MultBatchOptions.Implementation">
            <summary>
            The implementation to pick
            </summary>
        </member>
        <member name="M:NBitcoin.Secp256k1.Musig.MusigContext.GenerateNonce">
            <summary>
            This function derives a random secret nonce that will be required for signing and
            creates a private nonce whose public part intended to be sent to other signers.
            </summary>
            <returns>A private nonce whose public part intended to be sent to other signers</returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.Musig.MusigContext.GenerateNonce(System.ReadOnlySpan{System.Byte})">
            <summary>
            This function derives a secret nonce that will be required for signing and
            creates a private nonce whose public part intended to be sent to other signers.
            </summary>
            <param name="sessionId32">A unique session_id32. It is a "number used once". If empty, it will be randomly generated.</param>
            <returns>A private nonce whose public part intended to be sent to other signers</returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.Musig.MusigContext.GenerateNonce(System.UInt64,NBitcoin.Secp256k1.ECPrivKey)">
            <summary>
            This function derives a secret nonce that will be required for signing and
            creates a private nonce whose public part intended to be sent to other signers.
            </summary>
            <param name="counter">A unique counter. Never reuse the same value twice for the same msg32/pubkeys.</param>
            <param name="signingKey">Provide the message to be signed to increase misuse-resistance. If you do provide a signingKey, sessionId32 can instead be a counter (that must never repeat!). However, it is recommended to always choose session_id32 uniformly at random. Can be null.</param>
            <returns>A private nonce whose public part intended to be sent to other signers</returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.Musig.MusigContext.GenerateNonce(System.ReadOnlySpan{System.Byte},NBitcoin.Secp256k1.ECPrivKey)">
            <summary>
            This function derives a secret nonce that will be required for signing and
            creates a private nonce whose public part intended to be sent to other signers.
            </summary>
            <param name="sessionId32">A unique session_id32. It is a "number used once". If empty, it will be randomly generated.</param>
            <param name="signingKey">Provide the message to be signed to increase misuse-resistance. If you do provide a signingKey, sessionId32 can instead be a counter (that must never repeat!). However, it is recommended to always choose session_id32 uniformly at random. Can be null.</param>
            <returns>A private nonce whose public part intended to be sent to other signers</returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.Musig.MusigContext.GenerateNonce(System.ReadOnlySpan{System.Byte},NBitcoin.Secp256k1.ECPrivKey,System.ReadOnlySpan{System.Byte})">
            <summary>
            This function derives a secret nonce that will be required for signing and
            creates a private nonce whose public part intended to be sent to other signers.
            </summary>
            <param name="sessionId32">A unique session_id32. It is a "number used once". If empty, it will be randomly generated.</param>
            <param name="signingKey">Provide the message to be signed to increase misuse-resistance. If you do provide a signingKey, sessionId32 can instead be a counter (that must never repeat!). However, it is recommended to always choose session_id32 uniformly at random. Can be null.</param>
            <param name="extraInput32">Provide the message to be signed to increase misuse-resistance. The extra_input32 argument can be used to provide additional data that does not repeat in normal scenarios, such as the current time. Can be empty.</param>
            <returns>A private nonce whose public part intended to be sent to other signers</returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.Musig.MusigPrivNonce.GenerateMusigNonce(NBitcoin.Secp256k1.Context,System.ReadOnlySpan{System.Byte},NBitcoin.Secp256k1.ECPrivKey,System.ReadOnlySpan{System.Byte},NBitcoin.Secp256k1.ECXOnlyPubKey,System.ReadOnlySpan{System.Byte})">
            <summary>
            This function derives a secret nonce that will be required for signing and
            creates a private nonce whose public part intended to be sent to other signers.
            </summary>
            <param name="context">The context</param>
            <param name="sessionId32">A unique session_id32. It is a "number used once". If empty, it will be randomly generated.</param>
            <param name="signingKey">Provide the message to be signed to increase misuse-resistance. If you do provide a signingKey, sessionId32 can instead be a counter (that must never repeat!). However, it is recommended to always choose session_id32 uniformly at random. Can be null.</param>
            <param name="msg32">Provide the message to be signed to increase misuse-resistance. Can be empty.</param>
            <param name="aggregatePubKey">Provide the message to be signed to increase misuse-resistance. Can be null.</param>
            <param name="extraInput32">Provide the message to be signed to increase misuse-resistance. The extra_input32 argument can be used to provide additional data that does not repeat in normal scenarios, such as the current time. Can be empty.</param>
            <returns>A private nonce whose public part intended to be sent to other signers</returns>
        </member>
        <member name="M:NBitcoin.Secp256k1.Scalar.extract(System.Span{System.UInt32},System.UInt32@)">
            Extract the lowest 32 bits of (c0,c1,c2) into n, and left shift the number 32 bits. 
        </member>
        <member name="M:NBitcoin.Secp256k1.Scalar.CONST(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
             The Secp256k1 curve has an endomorphism, where lambda * (x, y) = (beta * x, y), where
             lambda is {0x53,0x63,0xad,0x4c,0xc0,0x5c,0x30,0xe0,0xa5,0x26,0x1c,0x02,0x88,0x12,0x64,0x5a,
                        0x12,0x2e,0x22,0xea,0x20,0x81,0x66,0x78,0xdf,0x02,0x96,0x7c,0x1b,0x23,0xbd,0x72}
            
             "Guide to Elliptic Curve Cryptography" (Hankerson, Menezes, Vanstone) gives an algorithm
             (algorithm 3.74) to find k1 and k2 given k, such that k1 + k2 * lambda == k mod n, and k1
             and k2 have a small size.
             It relies on constants a1, b1, a2, b2. These constants for the value of lambda above are:
            
             - a1 =      {0x30,0x86,0xd2,0x21,0xa7,0xd4,0x6b,0xcd,0xe8,0x6c,0x90,0xe4,0x92,0x84,0xeb,0x15}
             - b1 =     -{0xe4,0x43,0x7e,0xd6,0x01,0x0e,0x88,0x28,0x6f,0x54,0x7f,0xa9,0x0a,0xbf,0xe4,0xc3}
             - a2 = {0x01,0x14,0xca,0x50,0xf7,0xa8,0xe2,0xf3,0xf6,0x57,0xc1,0x10,0x8d,0x9d,0x44,0xcf,0xd8}
             - b2 =      {0x30,0x86,0xd2,0x21,0xa7,0xd4,0x6b,0xcd,0xe8,0x6c,0x90,0xe4,0x92,0x84,0xeb,0x15}
            
             The algorithm then computes c1 = round(b1 * k / n) and c2 = round(b2 * k / n), and gives
             k1 = k - (c1*a1 + c2*a2) and k2 = -(c1*b1 + c2*b2). Instead, we use modular arithmetic, and
             compute k1 as k - k2 * lambda, avoiding the need for constants a1 and a2.
            
             g1, g2 are precomputed constants used to replace division with a rounded multiplication
             when decomposing the scalar for an endomorphism-based point multiplication.
            
             The possibility of using precomputed estimates is mentioned in "Guide to Elliptic Curve
             Cryptography" (Hankerson, Menezes, Vanstone) in section 3.5.
            
             The derivation is described in the paper "Efficient Software Implementation of Public-Key
             Cryptography on Sensor Networks Using the MSP430X Microcontroller" (Gouvea, Oliveira, Lopez),
             Section 4.3 (here we use a somewhat higher-precision estimate):
             d = a1*b2 - b1*a2
             g1 = round((2^272)*b2/d)
             g2 = round((2^272)*b1/d)
            
             (Note that 'd' is also equal to the curve order here because [a1,b1] and [a2,b2] are found
             as outputs of the Extended Euclidean Algorithm on inputs 'order' and 'lambda').
            
             The function below splits a in r1 and r2, such that r1 + lambda * r2 == a (mod order).
        </member>
        <member name="T:NBitcoin.Secp256k1.BIP340NonceFunction">
            <summary>
            This nonce function is described in BIP-schnorr (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki)
            </summary>
        </member>
        <member name="M:NBitcoin.Secp256k1.SecpECDSASignature.#ctor(NBitcoin.Secp256k1.Scalar@,NBitcoin.Secp256k1.Scalar@,System.Boolean)">
            <summary>
            Create a signature from r and s
            </summary>
            <param name="r"></param>
            <param name="s"></param>
            <param name="enforceCheck">If true, will check that r and s are not zero or overflow. If false, we assume the caller made the checks</param>
            <exception cref="T:System.ArgumentException">Thrown if enforceCheck is true and r or s is not valid</exception>
        </member>
        <member name="M:NBitcoin.Secp256k1.SHA256.InitializeTagged(System.ReadOnlySpan{System.Byte})">
            <summary>
            Initializes a sha256 struct and writes the 64 byte string
            SHA256(tag)||SHA256(tag) into it.
            </summary>
            <param name="tag"></param>
        </member>
        <member name="M:NBitcoin.Secp256k1.SHA256.InitializeTagged(System.String)">
            <summary>
            Initializes a sha256 struct and writes the 64 byte string
            SHA256(tag)||SHA256(tag) into it.
            </summary>
            <param name="tag"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NBitcoin.Secp256k1.Wnaf.Fixed(System.Span{System.Int32},NBitcoin.Secp256k1.Scalar@,System.Int32)" -->
        <member name="F:NBitcoin.Sequence.SEQUENCE_LOCKTIME_DISABLE_FLAG">
            <summary>
            If this flag set, CTxIn::nSequence is NOT interpreted as a
            relative lock-time. 
            </summary>
        </member>
        <member name="F:NBitcoin.Sequence.SEQUENCE_LOCKTIME_TYPE_FLAG">
            <summary>
            If CTxIn::nSequence encodes a relative lock-time and this flag
            is set, the relative lock-time has units of 512 seconds,
            otherwise it specifies blocks with a granularity of 1. 
            </summary>
        </member>
        <member name="F:NBitcoin.Sequence.SEQUENCE_LOCKTIME_MASK">
            <summary>
            If CTxIn::nSequence encodes a relative lock-time, this mask is
            applied to extract that lock-time from the sequence field.
            </summary>
        </member>
        <member name="F:NBitcoin.Sequence.SEQUENCE_FINAL">
            <summary>
            Setting nSequence to this value for every input in a transaction
            disables nLockTime. */
            </summary>
            <remarks>
            If this flag set, CTxIn::nSequence is NOT interpreted as a
            relative lock-time. Setting the most significant bit of a
            sequence number disabled relative lock-time.
            </remarks>
        </member>
        <member name="F:NBitcoin.Sequence.MAX_BIP125_RBF_SEQUENCE">
            <summary>
            Setting nSequence to this value on any input in a transaction
            to signal the transaction is replaceable. */
            </summary>
        </member>
        <member name="F:NBitcoin.Sequence.SEQUENCE_LOCKTIME_GRANULARITY">
            <summary>
            In order to use the same number of bits to encode roughly the
            same wall-clock duration, and because blocks are naturally
            limited to occur every 600s on average, the minimum granularity
            for time-based relative lock-time is fixed at 512 seconds.
            Converting from CTxIn::nSequence to seconds is performed by
            multiplying by 512 = 2^9, or equivalently shifting up by
            9 bits. 
            </summary>
        </member>
        <member name="T:NBitcoin.ISigningRepository">
            <summary>
            Interface for injecting security sensitive stuffs to other objects.
            This is equivalent to `SigningProvider` class in bitcoin core.
            Currently used in OutputDescriptor to safely inject private key information
            </summary>
        </member>
        <member name="M:NBitcoin.ISigningRepository.TryGetScript(NBitcoin.ScriptId,NBitcoin.Script@)">
            <summary>
            In case of Witness Script, use HashForLookup Property as a key.
            </summary>
            <param name="scriptId"></param>
            <param name="script"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.ISigningRepository.SetScript(NBitcoin.ScriptId,NBitcoin.Script)">
            <summary>
            In case of Witness Script, use HashForLookup property as a key.
            </summary>
            <param name="scriptId"></param>
            <param name="script"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.ISigningRepository.Merge(NBitcoin.ISigningRepository)">
            <summary>
            Consume the argument and take everything it holds.
            This method should at least support consuming `FlatSigningRepository`.
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:NBitcoin.SlimChain">
            <summary>
            A thread safe, memory optimized chain of hashes representing the current chain
            </summary>
        </member>
        <member name="M:NBitcoin.SlimChain.TrySetTip(NBitcoin.uint256,NBitcoin.uint256,System.Boolean)">
            <summary>
            Set a new tip in the chain
            </summary>
            <param name="newTip">The new tip</param>
            <param name="previous">The block hash before the new tip</param>
            <param name="nopIfContainsTip">If true and the new tip is already included somewhere in the chain, do nothing</param>
            <returns>True if newTip is the new tip</returns>
        </member>
        <member name="M:NBitcoin.SlimChain.FindFork(NBitcoin.BlockLocator)">
            <summary>
            Returns the first found block
            </summary>
            <param name="hashes">Hash to search for</param>
            <returns>First found block or null</returns>
        </member>
        <member name="M:NBitcoin.PayToPubkeyTemplate.ExtractScriptPubKeyParameters(NBitcoin.Script)">
            <summary>
            Extract the public key or null from the script, perform quick check on pubkey
            </summary>
            <param name="scriptPubKey"></param>
            <returns>The public key</returns>
        </member>
        <member name="M:NBitcoin.PayToPubkeyTemplate.ExtractScriptPubKeyParameters(NBitcoin.Script,System.Boolean)">
            <summary>
            Extract the public key or null from the script
            </summary>
            <param name="scriptPubKey"></param>
            <param name="deepCheck">Whether deep checks are done on public key</param>
            <returns>The public key</returns>
        </member>
        <member name="M:NBitcoin.PayToWitScriptHashTemplate.ExtractWitScriptParameters(NBitcoin.WitScript,NBitcoin.WitScriptId)">
            <summary>
            Extract witness redeem from WitScript
            </summary>
            <param name="witScript">Witscript to extract information from</param>
            <param name="expectedScriptId">Expected redeem hash</param>
            <returns>The witness redeem</returns>
        </member>
        <member name="M:NBitcoin.WitProgramParameters.NeedWitnessRedeemScript">
            <summary>
            Check if this program represent P2WSH
            </summary>
            <returns>True if P2WSH</returns>
        </member>
        <member name="T:NBitcoin.Target">
            <summary>
            Represent the challenge that miners must solve for finding a new block
            </summary>
        </member>
        <member name="M:NBitcoin.OutPoint.TryParse(System.String,NBitcoin.OutPoint@)">
            <summary>
            Parse an outpoint with either the format:
            [txid]:[outputindex]
            [txid]-[outputindex]
            [txid][outputindex] where outputindex is in hexadecimal, 4 bytes in little endian (serialization format)
            </summary>
            <param name="str">The string to parse</param>
            <param name="result">The outpoint</param>
            <returns>True if parsing succeed</returns>
        </member>
        <member name="M:NBitcoin.OutPoint.Parse(System.String)">
            <summary>
            Parse an outpoint with either the format:
            [txid]:[outputindex]
            [txid]-[outputindex]
            [txid][outputindex] where txid is little endian and outputindex is in hexadecimal, 4 bytes in little endian (serialization format)
            </summary>
            <param name="str">The string to parse</param>
            <returns>The outpoint</returns>
        </member>
        <member name="M:NBitcoin.TxIn.GetSigner">
            <summary>
            Try to get the expected scriptPubKey of this TxIn based on its scriptSig and witScript.
            </summary>
            <returns>Null if could not infer the scriptPubKey, else, the expected scriptPubKey</returns>
        </member>
        <member name="P:NBitcoin.TxIn.WitScript">
            <summary>
            The witness script (Witness script is not serialized and deserialized at the TxIn level, but at the Transaction level)
            </summary>
        </member>
        <member name="P:NBitcoin.IndexedTxIn.Index">
            <summary>
            The index of this TxIn in its transaction
            </summary>
        </member>
        <member name="M:NBitcoin.TxInList.FindIndexedInput(NBitcoin.OutPoint)">
            <summary>
            Returns the IndexedTxIn whose PrevOut is equal to <paramref name="outpoint"/> or null.
            </summary>
            <param name="outpoint">The outpoint being searched for</param>
            <returns>The IndexedTxIn which PrevOut is equal to <paramref name="outpoint"/> or null if not found</returns>
        </member>
        <member name="M:NBitcoin.TxInList.FindIndexedInput(System.Int32)">
            <summary>
            Returns the IndexedTxIn at index.
            </summary>
            <param name="index">the index</param>
            <returns>A IndexedTxIn</returns>
        </member>
        <member name="M:NBitcoin.WitScript.#ctor(System.Byte[][],System.Boolean)">
            <summary>
            Create a new WitnessScript
            </summary>
            <param name="script">Scripts</param>
            <param name="unsafe">If false, make a copy of the input script array</param>
        </member>
        <member name="M:NBitcoin.WitScript.#ctor(System.Collections.Generic.IEnumerable{System.Byte[]},System.Boolean)">
            <summary>
            Create a new WitnessScript
            </summary>
            <param name="script">Scripts</param>
        </member>
        <member name="M:NBitcoin.Transaction.PrecomputeHash(System.Boolean,System.Boolean)">
            <summary>
            Precompute the transaction hash and witness hash so that later calls to GetHash() and GetWitHash() will returns the precomputed hash
            </summary>
            <param name="invalidateExisting">If true, the previous precomputed hash is thrown away, else it is reused</param>
            <param name="lazily">If true, the hash will be calculated and cached at the first call to GetHash(), else it will be immediately</param>
        </member>
        <member name="M:NBitcoin.Transaction.GetVirtualSize">
            <summary>
            Size of the transaction discounting the witness (Used for fee calculation)
            </summary>
            <returns>Transaction size</returns>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.BitcoinSecret,NBitcoin.ICoin)">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="key">Private key</param>
            <param name="coin">Coin to sign</param>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.BitcoinSecret,System.Collections.Generic.IEnumerable{NBitcoin.ICoin})">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="key">Private key</param>
            <param name="coins">Coins to sign</param>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(System.Collections.Generic.IEnumerable{NBitcoin.BitcoinSecret},System.Collections.Generic.IEnumerable{NBitcoin.ICoin})">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="keys">Private keys</param>
            <param name="coins">Coins to sign</param>
        </member>
        <member name="M:NBitcoin.Transaction.GetFee(NBitcoin.ICoin[])">
            <summary>
            Calculate the fee of the transaction
            </summary>
            <param name="spentCoins">Coins being spent</param>
            <returns>Fee or null if some spent coins are missing or if spentCoins is null</returns>
        </member>
        <member name="M:NBitcoin.Transaction.GetFee(NBitcoin.TxOut[])">
            <summary>
            Calculate the fee of the transaction
            </summary>
            <param name="spentOutputs">Outputs being spent</param>
            <returns>Fee or null if some spent coins are missing or if spentCoins is null</returns>
        </member>
        <member name="M:NBitcoin.Transaction.GetFeeRate(NBitcoin.ICoin[])">
            <summary>
            Calculate the fee rate of the transaction
            </summary>
            <param name="spentCoins">Coins being spent</param>
            <returns>Fee or null if some spent coins are missing or if spentCoins is null</returns>
        </member>
        <member name="F:NBitcoin.Transaction.LockTimeFlags.VerifySequence">
            <summary>
            Interpret sequence numbers as relative lock-time constraints.
            </summary>
        </member>
        <member name="F:NBitcoin.Transaction.LockTimeFlags.MedianTimePast">
            <summary>
             Use GetMedianTimePast() instead of nTime for end point timestamp.
            </summary>
        </member>
        <member name="M:NBitcoin.Transaction.CheckSequenceLocks(System.Int32[],NBitcoin.ChainedBlock,NBitcoin.Transaction.LockTimeFlags)">
            <summary>
            Calculates the block height and time which the transaction must be later than
            in order to be considered final in the context of BIP 68.  It also removes
            from the vector of input heights any entries which did not correspond to sequence
            locked inputs as they do not affect the calculation.
            </summary>
            <param name="prevHeights">Previous Height</param>
            <param name="block">The block being evaluated</param>
            <param name="flags">If VerifySequence is not set, returns always true SequenceLock</param>
            <returns>Sequence lock of minimum SequenceLock to satisfy</returns>
        </member>
        <member name="M:NBitcoin.Transaction.CalculateSequenceLocks(System.Int32[],NBitcoin.ChainedBlock,NBitcoin.Transaction.LockTimeFlags)">
            <summary>
            Calculates the block height and time which the transaction must be later than
            in order to be considered final in the context of BIP 68.  It also removes
            from the vector of input heights any entries which did not correspond to sequence
            locked inputs as they do not affect the calculation.
            </summary>
            <param name="prevHeights">Previous Height</param>
            <param name="block">The block being evaluated</param>
            <param name="flags">If VerifySequence is not set, returns always true SequenceLock</param>
            <returns>Sequence lock of minimum SequenceLock to satisfy</returns>
        </member>
        <member name="M:NBitcoin.Transaction.WithOptions(NBitcoin.TransactionOptions)">
            <summary>
            Create a transaction with the specified option only. (useful for stripping data from a transaction)
            </summary>
            <param name="options">Options to keep</param>
            <returns>A new transaction with only the options wanted</returns>
        </member>
        <member name="M:NBitcoin.Transaction.Check">
            <summary>
            Context free transaction check
            </summary>
            <returns>The error or success of the check</returns>
        </member>
        <member name="P:NBitcoin.SigningOptions.SigHash">
            <summary>
            What are we signing (default: SigHash.All)
            </summary>
        </member>
        <member name="P:NBitcoin.SigningOptions.TaprootSigHash">
            <summary>
            What are we signing for taproot (default: SigHash.Default)
            </summary>
        </member>
        <member name="P:NBitcoin.SigningOptions.EnforceLowR">
            <summary>
            Do we try to get shorter signatures? (default: true)
            </summary>
        </member>
        <member name="P:NBitcoin.SigningOptions.PrecomputedTransactionData">
            <summary>
            Providing the PrecomputedTransactionData speed up signing time, by pre computing one several hashes need
            for the calculation of the signatures of every input.
            
            For taproot transaction signing, the precomputed transaction data is required if some of the inputs does not
            belong to the signer.
            </summary>
        </member>
        <member name="T:NBitcoin.DefaultCoinSelector">
            <summary>
            Algorithm implemented by bitcoin core https://github.com/bitcoin/bitcoin/blob/3015e0bca6bc2cb8beb747873fdf7b80e74d679f/src/wallet.cpp#L1276
            Minimize the change
            </summary>
        </member>
        <member name="P:NBitcoin.DefaultCoinSelector.GroupByScriptPubKey">
            <summary>
            Select all coins belonging to same scriptPubKey together to protect privacy. (Default: true)
            </summary>
        </member>
        <member name="P:NBitcoin.DefaultCoinSelector.Iterations">
            <summary>
            Number of iterations in the knapsack algorithm (Default: 100)
            </summary>
        </member>
        <member name="T:NBitcoin.NotEnoughFundsException">
            <summary>
            Exception thrown when not enough funds are present for verifying or building a transaction
            </summary>
        </member>
        <member name="P:NBitcoin.NotEnoughFundsException.Group">
            <summary>
            The group name who is missing the funds
            </summary>
        </member>
        <member name="P:NBitcoin.NotEnoughFundsException.Missing">
            <summary>
            Amount of Money missing
            </summary>
        </member>
        <member name="T:NBitcoin.TransactionBuilder">
            <summary>
            A class for building and signing all sort of transactions easily (http://www.codeproject.com/Articles/835098/NBitcoin-Build-Them-All)
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.LeftOverChange">
            <summary>
            Additional change that should be swept to change later
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.DustPreventionTotalRemoved">
            <summary>
            Total of output value that was removed via dust prevention mechanism
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.SentOutput">
            <summary>
            What is curently sent
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.FeeTxOut">
            <summary>
            The fee txout (change or substracted output)
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.FeePaid">
            <summary>
            Whether fee are already paid
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.FixedFee">
            <summary>
            Fixed fee of SendFee
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.MinFee">
            <summary>
            Dogecoin has weird requirement.
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.SizeFee">
            <summary>
            Size fee is initially sent to 0 for the first pass.
            Then we can do a second pass with the right Size fee.
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.TransactionBuildingContext.GroupContext.MinValue">
            <summary>
            The minimum UTXO value to select
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.ShuffleRandom">
            <summary>
            The random number generator used for shuffling transaction outputs or selected coins
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.DustPrevention">
            <summary>
            If true, it will remove any TxOut below Dust, so the transaction get correctly relayed by the network. (Default: true)
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.OptInRBF">
            <summary>
            If true, it will signal the transaction replaceability in every input. (Default: false)
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.ShuffleInputs">
            <summary>
            If true, the transaction builder tries to shuffle inputs
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.ShuffleOutputs">
            <summary>
            If true, the transaction builder tries to shuffles outputs
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.MergeOutputs">
            <summary>
            If true and the transaction has two outputs sending to the same scriptPubKey, those will be merged into a single output. (Default: true)
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.FilterUneconomicalCoins">
            <summary>
            If true, the TransactionBuilder will not select coins whose fee to spend is higher than its value. (Default: true)
            The cost of spending a coin is based on the <see cref="P:NBitcoin.TransactionBuilder.FilterUneconomicalCoinsRate"/>.
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.FilterUneconomicalCoinsRate">
            <summary>
            If <see cref="P:NBitcoin.TransactionBuilder.FilterUneconomicalCoins"/> is true, this rate is used to know if an output is economical.
            This property is set automatically when calling <see cref="M:NBitcoin.TransactionBuilder.SendEstimatedFees(NBitcoin.FeeRate)"/> or <see cref="M:NBitcoin.TransactionBuilder.SendEstimatedFeesSplit(NBitcoin.FeeRate)"/>.
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.CoinFinder">
            <summary>
            A callback used by the TransactionBuilder when it does not find the coin for an input
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.KeyFinder">
            <summary>
            A callback used by the TransactionBuilder when it does not find the key for a scriptPubKey
            </summary>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SetGroupName(System.String)">
            <summary>
            Set the name of this group (group are separated by call to Then())
            </summary>
            <param name="groupName">Name of the group</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.IDestination,NBitcoin.Money)">
            <summary>
            Send bitcoins to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="amount">The amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAll(NBitcoin.IDestination)">
            <summary>
            Send all coins added so far with no change (sweep), substracting fees from the total amount
            </summary>
            <param name="destination"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAll(NBitcoin.Script)">
            <summary>
            Send all coins added so far with no change (sweep), substracting fees from the total amount
            </summary>
            <param name="scriptPubKey"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAllRemaining(NBitcoin.IDestination)">
            <summary>
            Send all the remaining available coins to this destination
            </summary>
            <param name="destination"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAllRemaining(NBitcoin.Script)">
            <summary>
            Send all the remaining available coins to this destination
            </summary>
            <param name="scriptPubKey"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAllRemainingToChange">
            <summary>
            Send all the remaining available coins to the change
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.Script,NBitcoin.Money)">
            <summary>
            Send bitcoins to a destination
            </summary>
            <param name="scriptPubKey">The destination</param>
            <param name="amount">The amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SubtractFees">
            <summary>
            Will subtract fees from the previous TxOut added by the last TransactionBuilder.Send() call
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.IDestination,NBitcoin.IMoney)">
            <summary>
            Send a money amount to the destination
            </summary>
            <param name="destination">The destination</param>
            <param name="amount">The amount (supported : Money, AssetMoney, MoneyBag)</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">The coin type is not supported</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.Script,NBitcoin.IMoney)">
            <summary>
            Send a money amount to the destination
            </summary>
            <param name="scriptPubKey">The destination</param>
            <param name="amount">The amount (supported : Money, AssetMoney, MoneyBag)</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">The coin type is not supported</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAsset(NBitcoin.IDestination,NBitcoin.OpenAsset.AssetMoney)">
            <summary>
            Send assets (Open Asset) to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="asset">The asset and amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAsset(NBitcoin.IDestination,NBitcoin.OpenAsset.AssetId,System.UInt64)">
            <summary>
            Send assets (Open Asset) to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="assetId">The asset and amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SetTransactionPolicy(NBitcoin.Policy.StandardTransactionPolicy)">
            <summary>
            Set transaction policy fluently
            </summary>
            <param name="policy">The policy</param>
            <returns>this</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendEstimatedFees(NBitcoin.FeeRate)">
            <summary>
            Split the estimated fees across the several groups (separated by Then())
            </summary>
            <param name="feeRate"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendEstimatedFeesSplit(NBitcoin.FeeRate)">
            <summary>
            Estimate the fee needed for the transaction, and split among groups according to their fee weight
            </summary>
            <param name="feeRate"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendFeesSplit(NBitcoin.Money)">
            <summary>
            Send the fee splitted among groups according to their fee weight
            </summary>
            <param name="fees"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SetFeeWeight(System.Decimal)">
            <summary>
            If using SendFeesSplit or SendEstimatedFeesSplit, determine the weight this group participate in paying the fees
            </summary>
            <param name="feeWeight">The weight of fee participation</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.BuildPSBT(System.Boolean)">
            <summary>
            Build a PSBT (Partially signed bitcoin transaction)
            </summary>
            <param name="sign">True if signs all inputs with the available keys</param>
            <param name="sigHash">The sighash for signing (ignored if sign is false)</param>
            <returns>A PSBT</returns>
            <exception cref="T:NBitcoin.NotEnoughFundsException">Not enough funds are available</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.CreatePSBTFrom(NBitcoin.Transaction,System.Boolean)">
            <summary>
            Create a PSBT from a transaction
            </summary>
            <param name="tx">The transaction</param>
            <param name="sign">If true, the transaction builder will sign this transaction</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.ExtractSignatures(NBitcoin.PSBT,NBitcoin.Transaction)">
            <summary>
            Try to extract the signatures from <paramref name="transaction"/> into the <paramref name="psbt"/>.
            </summary>
            <param name="psbt">The PSBT to extract signatures to.</param>
            <param name="transaction">The transaction from which signatures will get extracted.</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.UpdatePSBT(NBitcoin.PSBT)">
            <summary>
            Update information in the PSBT with informations that the transaction builder is holding
            </summary>
            <param name="psbt">A PSBT</param>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.BuildTransaction(System.Boolean)">
            <summary>
            Build the transaction
            </summary>
            <param name="sign">True if signs all inputs with the available keys</param>
            <returns>The transaction</returns>
            <exception cref="T:NBitcoin.NotEnoughFundsException">Not enough funds are available</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SignTransactionInPlace(NBitcoin.Transaction)">
            <summary>
            Sign the transaction passed as parameter
            </summary>
            <param name="transaction">The transaction</param>
            <returns>The transaction object as the one passed as parameter</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateFeeRate(NBitcoin.Transaction)">
            <summary>
            Estimate the fee rate of the transaction once it is fully signed.
            </summary>
            <param name="tx">The transaction to be signed</param>
            <returns>The fee rate, or null if the transaction builder is missing previous coins</returns>
            <exception cref="T:NBitcoin.CoinNotFoundException">If the transaction builder is missing some coins</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.TransactionValidator)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="validator">The transaction validator</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.Money)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFees">The expected fees (more or less 10%)</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.TransactionValidator,NBitcoin.Money)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="validator">The transaction validator</param>
            <param name="expectedFees">The expected fees (more or less 10%)</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.FeeRate)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.TransactionValidator,NBitcoin.FeeRate)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="validator">The transaction validator</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.TransactionValidator,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="validator">The transaction validator</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.Money,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed, have enough fees, and follow the Standard and Miner Transaction Policy rules
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFees">The expected fees (more or less 10%)</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.TransactionValidator,NBitcoin.Money,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed, have enough fees, and follow the Standard and Miner Transaction Policy rules
            </summary>
            <param name="validator">The transaction validator</param>
            <param name="expectedFees">The expected fees (more or less 10%)</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.FeeRate,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.TransactionValidator,NBitcoin.FeeRate,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="validator">The transaction validator</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Check(NBitcoin.Transaction,NBitcoin.FeeRate)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">he transaction to check</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <returns>Detected errors</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Check(NBitcoin.Transaction,NBitcoin.Money)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">he transaction to check</param>
            <param name="expectedFee">The expected fee</param>
            <returns>Detected errors</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Check(NBitcoin.Transaction)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">he transaction to check</param>
            <returns>Detected errors</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.FindSpentCoins(NBitcoin.Transaction)">
            <summary>
            Find spent coins of a transaction
            </summary>
            <param name="tx">The transaction</param>
            <returns>Array of size tx.Input.Count, if a coin is not fund, a null coin is returned.</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateSize(NBitcoin.Transaction)">
            <summary>
            Estimate the physical size of the transaction
            </summary>
            <param name="tx">The transaction to be estimated</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateSize(NBitcoin.Transaction,System.Boolean)">
            <summary>
            Estimate the size of the transaction
            </summary>
            <param name="tx">The transaction to be estimated</param>
            <param name="virtualSize">If true, returns the size on which fee calculation are based, else returns the physical byte size</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateSizes(NBitcoin.Transaction,System.Int32@,System.Int32@)">
            <summary>
            Estimate the witness size and the base size of a transaction
            </summary>
            <param name="tx">The transaction</param>
            <param name="witSize">The witness size</param>
            <param name="baseSize">The base size</param>
            <exception cref="T:NBitcoin.CoinNotFoundException">If the transaction builder is missing some coins</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateFees(NBitcoin.FeeRate)">
            <summary>
            Estimate fees of the built transaction
            </summary>
            <param name="feeRate">Fee rate</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateFees(NBitcoin.Transaction,NBitcoin.FeeRate)">
            <summary>
            Estimate fees of an unsigned transaction
            </summary>
            <param name="tx"></param>
            <param name="feeRate">Fee rate</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Then">
            <summary>
            Create a new participant in the transaction with its own set of coins and keys
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Then(System.String)">
            <summary>
            Switch to another participant in the transaction, or create a new one if it is not found.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionSignature.IsValid(System.Byte[],NBitcoin.ScriptVerify)">
            <summary>
            Check if valid transaction signature
            </summary>
            <param name="sig">Signature in bytes</param>
            <param name="scriptVerify">Verification rules</param>
            <returns>True if valid</returns>
        </member>
        <member name="M:NBitcoin.TransactionSignature.IsValid(System.Byte[],NBitcoin.ScriptVerify,NBitcoin.ScriptError@)">
            <summary>
            Check if valid transaction signature
            </summary>
            <param name="sig">The signature</param>
            <param name="scriptVerify">Verification rules</param>
            <param name="error">Error</param>
            <returns>True if valid</returns>
        </member>
        <member name="M:NBitcoin.TransactionSignature.MakeCanonical">
            <summary>
            Enforce LowS on the signature
            </summary>
        </member>
        <member name="M:NBitcoin.uint256.#ctor(System.String)">
            <summary>
            Create a uint256 from a string in big endian
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:NBitcoin.uint256.ToBytes(System.Byte[])">
            <summary>
            Write this instance to the output in little endian
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:NBitcoin.uint256.ToBytes(System.Byte[],System.Boolean)">
            <summary>
            Write this instance to the output
            </summary>
            <param name="output"></param>
            <param name="lendian"></param>
        </member>
        <member name="M:NBitcoin.Extensions.AsHDKeyCache(NBitcoin.IHDKey)">
            <summary>
            Deriving an HDKey is normally time consuming, this wrap the IHDKey in a new HD object which can cache derivations
            </summary>
            <param name="hdkey">The hdKey to wrap</param>
            <returns>An hdkey which cache derivations, of the parameter if it is already itself a cache</returns>
        </member>
        <member name="M:NBitcoin.Extensions.AsHDKeyCache(NBitcoin.IHDScriptPubKey)">
            <summary>
            Deriving an IHDScriptPubKey is normally time consuming, this wrap the IHDScriptPubKey in a new IHDScriptPubKey object which can cache derivations
            </summary>
            <param name="hdScriptPubKey">The hdScriptPubKey to wrap</param>
            <returns>An hdkey which cache derivations, of the parameter if it is already itself a cache</returns>
        </member>
        <member name="M:NBitcoin.Extensions.Derive(NBitcoin.IHDKey,NBitcoin.KeyPath[])">
            <summary>
            Derive keyPaths as fast as possible using caching and parallelism
            </summary>
            <param name="hdkey">The hdKey to derive</param>
            <param name="keyPaths">keyPaths to derive</param>
            <returns>An array of keyPaths.Length size with the derived keys</returns>
        </member>
        <member name="M:NBitcoin.Extensions.ToUnixTimestamp(System.DateTime)">
            <summary>
            Converts a given DateTime into a Unix timestamp
            </summary>
            <param name="value">Any DateTime</param>
            <returns>The given DateTime in Unix timestamp format</returns>
        </member>
        <member name="M:NBitcoin.Extensions.UnixTimestamp(System.DateTime)">
            <summary>
            Gets a Unix timestamp representing the current moment
            </summary>
            <param name="ignored">Parameter ignored</param>
            <returns>Now expressed as a Unix timestamp</returns>
        </member>
        <member name="M:NBitcoin.ThreadSafeCollection`1.Add(`0)">
            <summary>
            Add an item to the collection
            </summary>
            <param name="item"></param>
            <returns>When disposed, the item is removed</returns>
        </member>
        <member name="M:NBitcoin.ThreadSafeList`1.Add(`0)">
            <summary>
            Add an item to the collection
            </summary>
            <param name="item"></param>
            <returns>When disposed, the item is removed</returns>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Utilities.Arrays">
            <summary> General array utilities.</summary>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Arrays.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Are two arrays equal.
            </summary>
            <param name="a">Left side.</param>
            <param name="b">Right side.</param>
            <returns>True if equal.</returns>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest">
            implementation of RipeMD see,
            http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.Sha256Digest">
             Draft FIPS 180-2 implementation of SHA-256. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha256Digest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.Sha256Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha256Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.KeccakDigest">
            <summary>
            Implementation of Keccak based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.KeccakDigest.GetByteLength">
             Return the size of block that the compression function is applied to in bytes.
            
             @return internal byte length of a block.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.Sha3Digest">
            <summary>
            Implementation of SHA-3 based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.GeneralDigest">
            base implementation of MD4 family style digest as outlined in
            "Handbook of Applied Cryptography", pages 344 - 347.
        </member>
    </members>
</doc>
